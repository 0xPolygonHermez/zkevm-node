// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	common "github.com/ethereum/go-ethereum/common"

	mock "github.com/stretchr/testify/mock"

	pgconn "github.com/jackc/pgconn"

	pgx "github.com/jackc/pgx/v4"

	state "github.com/0xPolygonHermez/zkevm-node/state"

	time "time"

	types "github.com/ethereum/go-ethereum/core/types"
)

// StorageMock is an autogenerated mock type for the storage type
type StorageMock struct {
	mock.Mock
}

type StorageMock_Expecter struct {
	mock *mock.Mock
}

func (_m *StorageMock) EXPECT() *StorageMock_Expecter {
	return &StorageMock_Expecter{mock: &_m.Mock}
}

// AddAccumulatedInputHash provides a mock function with given fields: ctx, batchNum, accInputHash, dbTx
func (_m *StorageMock) AddAccumulatedInputHash(ctx context.Context, batchNum uint64, accInputHash common.Hash, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchNum, accInputHash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddAccumulatedInputHash")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, common.Hash, pgx.Tx) error); ok {
		r0 = rf(ctx, batchNum, accInputHash, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddAccumulatedInputHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddAccumulatedInputHash'
type StorageMock_AddAccumulatedInputHash_Call struct {
	*mock.Call
}

// AddAccumulatedInputHash is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNum uint64
//   - accInputHash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddAccumulatedInputHash(ctx interface{}, batchNum interface{}, accInputHash interface{}, dbTx interface{}) *StorageMock_AddAccumulatedInputHash_Call {
	return &StorageMock_AddAccumulatedInputHash_Call{Call: _e.mock.On("AddAccumulatedInputHash", ctx, batchNum, accInputHash, dbTx)}
}

func (_c *StorageMock_AddAccumulatedInputHash_Call) Run(run func(ctx context.Context, batchNum uint64, accInputHash common.Hash, dbTx pgx.Tx)) *StorageMock_AddAccumulatedInputHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(common.Hash), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddAccumulatedInputHash_Call) Return(_a0 error) *StorageMock_AddAccumulatedInputHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddAccumulatedInputHash_Call) RunAndReturn(run func(context.Context, uint64, common.Hash, pgx.Tx) error) *StorageMock_AddAccumulatedInputHash_Call {
	_c.Call.Return(run)
	return _c
}

// AddBlock provides a mock function with given fields: ctx, block, dbTx
func (_m *StorageMock) AddBlock(ctx context.Context, block *state.Block, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, block, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.Block, pgx.Tx) error); ok {
		r0 = rf(ctx, block, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddBlock'
type StorageMock_AddBlock_Call struct {
	*mock.Call
}

// AddBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - block *state.Block
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddBlock(ctx interface{}, block interface{}, dbTx interface{}) *StorageMock_AddBlock_Call {
	return &StorageMock_AddBlock_Call{Call: _e.mock.On("AddBlock", ctx, block, dbTx)}
}

func (_c *StorageMock_AddBlock_Call) Run(run func(ctx context.Context, block *state.Block, dbTx pgx.Tx)) *StorageMock_AddBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.Block), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddBlock_Call) Return(_a0 error) *StorageMock_AddBlock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddBlock_Call) RunAndReturn(run func(context.Context, *state.Block, pgx.Tx) error) *StorageMock_AddBlock_Call {
	_c.Call.Return(run)
	return _c
}

// AddForcedBatch provides a mock function with given fields: ctx, forcedBatch, tx
func (_m *StorageMock) AddForcedBatch(ctx context.Context, forcedBatch *state.ForcedBatch, tx pgx.Tx) error {
	ret := _m.Called(ctx, forcedBatch, tx)

	if len(ret) == 0 {
		panic("no return value specified for AddForcedBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.ForcedBatch, pgx.Tx) error); ok {
		r0 = rf(ctx, forcedBatch, tx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddForcedBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddForcedBatch'
type StorageMock_AddForcedBatch_Call struct {
	*mock.Call
}

// AddForcedBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - forcedBatch *state.ForcedBatch
//   - tx pgx.Tx
func (_e *StorageMock_Expecter) AddForcedBatch(ctx interface{}, forcedBatch interface{}, tx interface{}) *StorageMock_AddForcedBatch_Call {
	return &StorageMock_AddForcedBatch_Call{Call: _e.mock.On("AddForcedBatch", ctx, forcedBatch, tx)}
}

func (_c *StorageMock_AddForcedBatch_Call) Run(run func(ctx context.Context, forcedBatch *state.ForcedBatch, tx pgx.Tx)) *StorageMock_AddForcedBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.ForcedBatch), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddForcedBatch_Call) Return(_a0 error) *StorageMock_AddForcedBatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddForcedBatch_Call) RunAndReturn(run func(context.Context, *state.ForcedBatch, pgx.Tx) error) *StorageMock_AddForcedBatch_Call {
	_c.Call.Return(run)
	return _c
}

// AddForkID provides a mock function with given fields: ctx, forkID, dbTx
func (_m *StorageMock) AddForkID(ctx context.Context, forkID state.ForkIDInterval, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, forkID, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddForkID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.ForkIDInterval, pgx.Tx) error); ok {
		r0 = rf(ctx, forkID, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddForkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddForkID'
type StorageMock_AddForkID_Call struct {
	*mock.Call
}

// AddForkID is a helper method to define mock.On call
//   - ctx context.Context
//   - forkID state.ForkIDInterval
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddForkID(ctx interface{}, forkID interface{}, dbTx interface{}) *StorageMock_AddForkID_Call {
	return &StorageMock_AddForkID_Call{Call: _e.mock.On("AddForkID", ctx, forkID, dbTx)}
}

func (_c *StorageMock_AddForkID_Call) Run(run func(ctx context.Context, forkID state.ForkIDInterval, dbTx pgx.Tx)) *StorageMock_AddForkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.ForkIDInterval), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddForkID_Call) Return(_a0 error) *StorageMock_AddForkID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddForkID_Call) RunAndReturn(run func(context.Context, state.ForkIDInterval, pgx.Tx) error) *StorageMock_AddForkID_Call {
	_c.Call.Return(run)
	return _c
}

// AddForkIDInterval provides a mock function with given fields: ctx, newForkID, dbTx
func (_m *StorageMock) AddForkIDInterval(ctx context.Context, newForkID state.ForkIDInterval, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, newForkID, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddForkIDInterval")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.ForkIDInterval, pgx.Tx) error); ok {
		r0 = rf(ctx, newForkID, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddForkIDInterval_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddForkIDInterval'
type StorageMock_AddForkIDInterval_Call struct {
	*mock.Call
}

// AddForkIDInterval is a helper method to define mock.On call
//   - ctx context.Context
//   - newForkID state.ForkIDInterval
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddForkIDInterval(ctx interface{}, newForkID interface{}, dbTx interface{}) *StorageMock_AddForkIDInterval_Call {
	return &StorageMock_AddForkIDInterval_Call{Call: _e.mock.On("AddForkIDInterval", ctx, newForkID, dbTx)}
}

func (_c *StorageMock_AddForkIDInterval_Call) Run(run func(ctx context.Context, newForkID state.ForkIDInterval, dbTx pgx.Tx)) *StorageMock_AddForkIDInterval_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.ForkIDInterval), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddForkIDInterval_Call) Return(_a0 error) *StorageMock_AddForkIDInterval_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddForkIDInterval_Call) RunAndReturn(run func(context.Context, state.ForkIDInterval, pgx.Tx) error) *StorageMock_AddForkIDInterval_Call {
	_c.Call.Return(run)
	return _c
}

// AddGeneratedProof provides a mock function with given fields: ctx, proof, dbTx
func (_m *StorageMock) AddGeneratedProof(ctx context.Context, proof *state.Proof, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, proof, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddGeneratedProof")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.Proof, pgx.Tx) error); ok {
		r0 = rf(ctx, proof, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddGeneratedProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGeneratedProof'
type StorageMock_AddGeneratedProof_Call struct {
	*mock.Call
}

// AddGeneratedProof is a helper method to define mock.On call
//   - ctx context.Context
//   - proof *state.Proof
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddGeneratedProof(ctx interface{}, proof interface{}, dbTx interface{}) *StorageMock_AddGeneratedProof_Call {
	return &StorageMock_AddGeneratedProof_Call{Call: _e.mock.On("AddGeneratedProof", ctx, proof, dbTx)}
}

func (_c *StorageMock_AddGeneratedProof_Call) Run(run func(ctx context.Context, proof *state.Proof, dbTx pgx.Tx)) *StorageMock_AddGeneratedProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.Proof), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddGeneratedProof_Call) Return(_a0 error) *StorageMock_AddGeneratedProof_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddGeneratedProof_Call) RunAndReturn(run func(context.Context, *state.Proof, pgx.Tx) error) *StorageMock_AddGeneratedProof_Call {
	_c.Call.Return(run)
	return _c
}

// AddGlobalExitRoot provides a mock function with given fields: ctx, exitRoot, dbTx
func (_m *StorageMock) AddGlobalExitRoot(ctx context.Context, exitRoot *state.GlobalExitRoot, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, exitRoot, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddGlobalExitRoot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.GlobalExitRoot, pgx.Tx) error); ok {
		r0 = rf(ctx, exitRoot, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddGlobalExitRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGlobalExitRoot'
type StorageMock_AddGlobalExitRoot_Call struct {
	*mock.Call
}

// AddGlobalExitRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - exitRoot *state.GlobalExitRoot
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddGlobalExitRoot(ctx interface{}, exitRoot interface{}, dbTx interface{}) *StorageMock_AddGlobalExitRoot_Call {
	return &StorageMock_AddGlobalExitRoot_Call{Call: _e.mock.On("AddGlobalExitRoot", ctx, exitRoot, dbTx)}
}

func (_c *StorageMock_AddGlobalExitRoot_Call) Run(run func(ctx context.Context, exitRoot *state.GlobalExitRoot, dbTx pgx.Tx)) *StorageMock_AddGlobalExitRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.GlobalExitRoot), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddGlobalExitRoot_Call) Return(_a0 error) *StorageMock_AddGlobalExitRoot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddGlobalExitRoot_Call) RunAndReturn(run func(context.Context, *state.GlobalExitRoot, pgx.Tx) error) *StorageMock_AddGlobalExitRoot_Call {
	_c.Call.Return(run)
	return _c
}

// AddL1InfoRootToExitRoot provides a mock function with given fields: ctx, exitRoot, dbTx
func (_m *StorageMock) AddL1InfoRootToExitRoot(ctx context.Context, exitRoot *state.L1InfoTreeExitRootStorageEntry, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, exitRoot, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddL1InfoRootToExitRoot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.L1InfoTreeExitRootStorageEntry, pgx.Tx) error); ok {
		r0 = rf(ctx, exitRoot, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddL1InfoRootToExitRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddL1InfoRootToExitRoot'
type StorageMock_AddL1InfoRootToExitRoot_Call struct {
	*mock.Call
}

// AddL1InfoRootToExitRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - exitRoot *state.L1InfoTreeExitRootStorageEntry
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddL1InfoRootToExitRoot(ctx interface{}, exitRoot interface{}, dbTx interface{}) *StorageMock_AddL1InfoRootToExitRoot_Call {
	return &StorageMock_AddL1InfoRootToExitRoot_Call{Call: _e.mock.On("AddL1InfoRootToExitRoot", ctx, exitRoot, dbTx)}
}

func (_c *StorageMock_AddL1InfoRootToExitRoot_Call) Run(run func(ctx context.Context, exitRoot *state.L1InfoTreeExitRootStorageEntry, dbTx pgx.Tx)) *StorageMock_AddL1InfoRootToExitRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.L1InfoTreeExitRootStorageEntry), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddL1InfoRootToExitRoot_Call) Return(_a0 error) *StorageMock_AddL1InfoRootToExitRoot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddL1InfoRootToExitRoot_Call) RunAndReturn(run func(context.Context, *state.L1InfoTreeExitRootStorageEntry, pgx.Tx) error) *StorageMock_AddL1InfoRootToExitRoot_Call {
	_c.Call.Return(run)
	return _c
}

// AddL2Block provides a mock function with given fields: ctx, batchNumber, l2Block, receipts, txsL2Hash, txsEGPData, dbTx
func (_m *StorageMock) AddL2Block(ctx context.Context, batchNumber uint64, l2Block *state.L2Block, receipts []*types.Receipt, txsL2Hash []common.Hash, txsEGPData []state.StoreTxEGPData, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchNumber, l2Block, receipts, txsL2Hash, txsEGPData, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddL2Block")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *state.L2Block, []*types.Receipt, []common.Hash, []state.StoreTxEGPData, pgx.Tx) error); ok {
		r0 = rf(ctx, batchNumber, l2Block, receipts, txsL2Hash, txsEGPData, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddL2Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddL2Block'
type StorageMock_AddL2Block_Call struct {
	*mock.Call
}

// AddL2Block is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - l2Block *state.L2Block
//   - receipts []*types.Receipt
//   - txsL2Hash []common.Hash
//   - txsEGPData []state.StoreTxEGPData
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddL2Block(ctx interface{}, batchNumber interface{}, l2Block interface{}, receipts interface{}, txsL2Hash interface{}, txsEGPData interface{}, dbTx interface{}) *StorageMock_AddL2Block_Call {
	return &StorageMock_AddL2Block_Call{Call: _e.mock.On("AddL2Block", ctx, batchNumber, l2Block, receipts, txsL2Hash, txsEGPData, dbTx)}
}

func (_c *StorageMock_AddL2Block_Call) Run(run func(ctx context.Context, batchNumber uint64, l2Block *state.L2Block, receipts []*types.Receipt, txsL2Hash []common.Hash, txsEGPData []state.StoreTxEGPData, dbTx pgx.Tx)) *StorageMock_AddL2Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(*state.L2Block), args[3].([]*types.Receipt), args[4].([]common.Hash), args[5].([]state.StoreTxEGPData), args[6].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddL2Block_Call) Return(_a0 error) *StorageMock_AddL2Block_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddL2Block_Call) RunAndReturn(run func(context.Context, uint64, *state.L2Block, []*types.Receipt, []common.Hash, []state.StoreTxEGPData, pgx.Tx) error) *StorageMock_AddL2Block_Call {
	_c.Call.Return(run)
	return _c
}

// AddLog provides a mock function with given fields: ctx, l, dbTx
func (_m *StorageMock) AddLog(ctx context.Context, l *types.Log, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, l, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddLog")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Log, pgx.Tx) error); ok {
		r0 = rf(ctx, l, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddLog'
type StorageMock_AddLog_Call struct {
	*mock.Call
}

// AddLog is a helper method to define mock.On call
//   - ctx context.Context
//   - l *types.Log
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddLog(ctx interface{}, l interface{}, dbTx interface{}) *StorageMock_AddLog_Call {
	return &StorageMock_AddLog_Call{Call: _e.mock.On("AddLog", ctx, l, dbTx)}
}

func (_c *StorageMock_AddLog_Call) Run(run func(ctx context.Context, l *types.Log, dbTx pgx.Tx)) *StorageMock_AddLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.Log), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddLog_Call) Return(_a0 error) *StorageMock_AddLog_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddLog_Call) RunAndReturn(run func(context.Context, *types.Log, pgx.Tx) error) *StorageMock_AddLog_Call {
	_c.Call.Return(run)
	return _c
}

// AddReceipt provides a mock function with given fields: ctx, receipt, dbTx
func (_m *StorageMock) AddReceipt(ctx context.Context, receipt *types.Receipt, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, receipt, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddReceipt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Receipt, pgx.Tx) error); ok {
		r0 = rf(ctx, receipt, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddReceipt'
type StorageMock_AddReceipt_Call struct {
	*mock.Call
}

// AddReceipt is a helper method to define mock.On call
//   - ctx context.Context
//   - receipt *types.Receipt
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddReceipt(ctx interface{}, receipt interface{}, dbTx interface{}) *StorageMock_AddReceipt_Call {
	return &StorageMock_AddReceipt_Call{Call: _e.mock.On("AddReceipt", ctx, receipt, dbTx)}
}

func (_c *StorageMock_AddReceipt_Call) Run(run func(ctx context.Context, receipt *types.Receipt, dbTx pgx.Tx)) *StorageMock_AddReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.Receipt), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddReceipt_Call) Return(_a0 error) *StorageMock_AddReceipt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddReceipt_Call) RunAndReturn(run func(context.Context, *types.Receipt, pgx.Tx) error) *StorageMock_AddReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// AddSequence provides a mock function with given fields: ctx, sequence, dbTx
func (_m *StorageMock) AddSequence(ctx context.Context, sequence state.Sequence, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, sequence, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddSequence")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.Sequence, pgx.Tx) error); ok {
		r0 = rf(ctx, sequence, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddSequence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSequence'
type StorageMock_AddSequence_Call struct {
	*mock.Call
}

// AddSequence is a helper method to define mock.On call
//   - ctx context.Context
//   - sequence state.Sequence
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddSequence(ctx interface{}, sequence interface{}, dbTx interface{}) *StorageMock_AddSequence_Call {
	return &StorageMock_AddSequence_Call{Call: _e.mock.On("AddSequence", ctx, sequence, dbTx)}
}

func (_c *StorageMock_AddSequence_Call) Run(run func(ctx context.Context, sequence state.Sequence, dbTx pgx.Tx)) *StorageMock_AddSequence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.Sequence), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddSequence_Call) Return(_a0 error) *StorageMock_AddSequence_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddSequence_Call) RunAndReturn(run func(context.Context, state.Sequence, pgx.Tx) error) *StorageMock_AddSequence_Call {
	_c.Call.Return(run)
	return _c
}

// AddTrustedReorg provides a mock function with given fields: ctx, reorg, dbTx
func (_m *StorageMock) AddTrustedReorg(ctx context.Context, reorg *state.TrustedReorg, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, reorg, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddTrustedReorg")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.TrustedReorg, pgx.Tx) error); ok {
		r0 = rf(ctx, reorg, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddTrustedReorg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTrustedReorg'
type StorageMock_AddTrustedReorg_Call struct {
	*mock.Call
}

// AddTrustedReorg is a helper method to define mock.On call
//   - ctx context.Context
//   - reorg *state.TrustedReorg
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddTrustedReorg(ctx interface{}, reorg interface{}, dbTx interface{}) *StorageMock_AddTrustedReorg_Call {
	return &StorageMock_AddTrustedReorg_Call{Call: _e.mock.On("AddTrustedReorg", ctx, reorg, dbTx)}
}

func (_c *StorageMock_AddTrustedReorg_Call) Run(run func(ctx context.Context, reorg *state.TrustedReorg, dbTx pgx.Tx)) *StorageMock_AddTrustedReorg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.TrustedReorg), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddTrustedReorg_Call) Return(_a0 error) *StorageMock_AddTrustedReorg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddTrustedReorg_Call) RunAndReturn(run func(context.Context, *state.TrustedReorg, pgx.Tx) error) *StorageMock_AddTrustedReorg_Call {
	_c.Call.Return(run)
	return _c
}

// AddVerifiedBatch provides a mock function with given fields: ctx, verifiedBatch, dbTx
func (_m *StorageMock) AddVerifiedBatch(ctx context.Context, verifiedBatch *state.VerifiedBatch, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, verifiedBatch, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddVerifiedBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.VerifiedBatch, pgx.Tx) error); ok {
		r0 = rf(ctx, verifiedBatch, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddVerifiedBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddVerifiedBatch'
type StorageMock_AddVerifiedBatch_Call struct {
	*mock.Call
}

// AddVerifiedBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - verifiedBatch *state.VerifiedBatch
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddVerifiedBatch(ctx interface{}, verifiedBatch interface{}, dbTx interface{}) *StorageMock_AddVerifiedBatch_Call {
	return &StorageMock_AddVerifiedBatch_Call{Call: _e.mock.On("AddVerifiedBatch", ctx, verifiedBatch, dbTx)}
}

func (_c *StorageMock_AddVerifiedBatch_Call) Run(run func(ctx context.Context, verifiedBatch *state.VerifiedBatch, dbTx pgx.Tx)) *StorageMock_AddVerifiedBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.VerifiedBatch), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddVerifiedBatch_Call) Return(_a0 error) *StorageMock_AddVerifiedBatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddVerifiedBatch_Call) RunAndReturn(run func(context.Context, *state.VerifiedBatch, pgx.Tx) error) *StorageMock_AddVerifiedBatch_Call {
	_c.Call.Return(run)
	return _c
}

// AddVirtualBatch provides a mock function with given fields: ctx, virtualBatch, dbTx
func (_m *StorageMock) AddVirtualBatch(ctx context.Context, virtualBatch *state.VirtualBatch, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, virtualBatch, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for AddVirtualBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.VirtualBatch, pgx.Tx) error); ok {
		r0 = rf(ctx, virtualBatch, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_AddVirtualBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddVirtualBatch'
type StorageMock_AddVirtualBatch_Call struct {
	*mock.Call
}

// AddVirtualBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - virtualBatch *state.VirtualBatch
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) AddVirtualBatch(ctx interface{}, virtualBatch interface{}, dbTx interface{}) *StorageMock_AddVirtualBatch_Call {
	return &StorageMock_AddVirtualBatch_Call{Call: _e.mock.On("AddVirtualBatch", ctx, virtualBatch, dbTx)}
}

func (_c *StorageMock_AddVirtualBatch_Call) Run(run func(ctx context.Context, virtualBatch *state.VirtualBatch, dbTx pgx.Tx)) *StorageMock_AddVirtualBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.VirtualBatch), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_AddVirtualBatch_Call) Return(_a0 error) *StorageMock_AddVirtualBatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_AddVirtualBatch_Call) RunAndReturn(run func(context.Context, *state.VirtualBatch, pgx.Tx) error) *StorageMock_AddVirtualBatch_Call {
	_c.Call.Return(run)
	return _c
}

// BatchNumberByL2BlockNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) BatchNumberByL2BlockNumber(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for BatchNumberByL2BlockNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) uint64); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_BatchNumberByL2BlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchNumberByL2BlockNumber'
type StorageMock_BatchNumberByL2BlockNumber_Call struct {
	*mock.Call
}

// BatchNumberByL2BlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) BatchNumberByL2BlockNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_BatchNumberByL2BlockNumber_Call {
	return &StorageMock_BatchNumberByL2BlockNumber_Call{Call: _e.mock.On("BatchNumberByL2BlockNumber", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_BatchNumberByL2BlockNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_BatchNumberByL2BlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_BatchNumberByL2BlockNumber_Call) Return(_a0 uint64, _a1 error) *StorageMock_BatchNumberByL2BlockNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_BatchNumberByL2BlockNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (uint64, error)) *StorageMock_BatchNumberByL2BlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// Begin provides a mock function with given fields: ctx
func (_m *StorageMock) Begin(ctx context.Context) (pgx.Tx, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Begin")
	}

	var r0 pgx.Tx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (pgx.Tx, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) pgx.Tx); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_Begin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Begin'
type StorageMock_Begin_Call struct {
	*mock.Call
}

// Begin is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StorageMock_Expecter) Begin(ctx interface{}) *StorageMock_Begin_Call {
	return &StorageMock_Begin_Call{Call: _e.mock.On("Begin", ctx)}
}

func (_c *StorageMock_Begin_Call) Run(run func(ctx context.Context)) *StorageMock_Begin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StorageMock_Begin_Call) Return(_a0 pgx.Tx, _a1 error) *StorageMock_Begin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_Begin_Call) RunAndReturn(run func(context.Context) (pgx.Tx, error)) *StorageMock_Begin_Call {
	_c.Call.Return(run)
	return _c
}

// BuildChangeL2Block provides a mock function with given fields: deltaTimestamp, l1InfoTreeIndex
func (_m *StorageMock) BuildChangeL2Block(deltaTimestamp uint32, l1InfoTreeIndex uint32) []byte {
	ret := _m.Called(deltaTimestamp, l1InfoTreeIndex)

	if len(ret) == 0 {
		panic("no return value specified for BuildChangeL2Block")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint32, uint32) []byte); ok {
		r0 = rf(deltaTimestamp, l1InfoTreeIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// StorageMock_BuildChangeL2Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildChangeL2Block'
type StorageMock_BuildChangeL2Block_Call struct {
	*mock.Call
}

// BuildChangeL2Block is a helper method to define mock.On call
//   - deltaTimestamp uint32
//   - l1InfoTreeIndex uint32
func (_e *StorageMock_Expecter) BuildChangeL2Block(deltaTimestamp interface{}, l1InfoTreeIndex interface{}) *StorageMock_BuildChangeL2Block_Call {
	return &StorageMock_BuildChangeL2Block_Call{Call: _e.mock.On("BuildChangeL2Block", deltaTimestamp, l1InfoTreeIndex)}
}

func (_c *StorageMock_BuildChangeL2Block_Call) Run(run func(deltaTimestamp uint32, l1InfoTreeIndex uint32)) *StorageMock_BuildChangeL2Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint32), args[1].(uint32))
	})
	return _c
}

func (_c *StorageMock_BuildChangeL2Block_Call) Return(_a0 []byte) *StorageMock_BuildChangeL2Block_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_BuildChangeL2Block_Call) RunAndReturn(run func(uint32, uint32) []byte) *StorageMock_BuildChangeL2Block_Call {
	_c.Call.Return(run)
	return _c
}

// CheckProofContainsCompleteSequences provides a mock function with given fields: ctx, proof, dbTx
func (_m *StorageMock) CheckProofContainsCompleteSequences(ctx context.Context, proof *state.Proof, dbTx pgx.Tx) (bool, error) {
	ret := _m.Called(ctx, proof, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for CheckProofContainsCompleteSequences")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.Proof, pgx.Tx) (bool, error)); ok {
		return rf(ctx, proof, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *state.Proof, pgx.Tx) bool); ok {
		r0 = rf(ctx, proof, dbTx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *state.Proof, pgx.Tx) error); ok {
		r1 = rf(ctx, proof, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_CheckProofContainsCompleteSequences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckProofContainsCompleteSequences'
type StorageMock_CheckProofContainsCompleteSequences_Call struct {
	*mock.Call
}

// CheckProofContainsCompleteSequences is a helper method to define mock.On call
//   - ctx context.Context
//   - proof *state.Proof
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) CheckProofContainsCompleteSequences(ctx interface{}, proof interface{}, dbTx interface{}) *StorageMock_CheckProofContainsCompleteSequences_Call {
	return &StorageMock_CheckProofContainsCompleteSequences_Call{Call: _e.mock.On("CheckProofContainsCompleteSequences", ctx, proof, dbTx)}
}

func (_c *StorageMock_CheckProofContainsCompleteSequences_Call) Run(run func(ctx context.Context, proof *state.Proof, dbTx pgx.Tx)) *StorageMock_CheckProofContainsCompleteSequences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.Proof), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_CheckProofContainsCompleteSequences_Call) Return(_a0 bool, _a1 error) *StorageMock_CheckProofContainsCompleteSequences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_CheckProofContainsCompleteSequences_Call) RunAndReturn(run func(context.Context, *state.Proof, pgx.Tx) (bool, error)) *StorageMock_CheckProofContainsCompleteSequences_Call {
	_c.Call.Return(run)
	return _c
}

// CleanupGeneratedProofs provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) CleanupGeneratedProofs(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for CleanupGeneratedProofs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) error); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_CleanupGeneratedProofs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanupGeneratedProofs'
type StorageMock_CleanupGeneratedProofs_Call struct {
	*mock.Call
}

// CleanupGeneratedProofs is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) CleanupGeneratedProofs(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_CleanupGeneratedProofs_Call {
	return &StorageMock_CleanupGeneratedProofs_Call{Call: _e.mock.On("CleanupGeneratedProofs", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_CleanupGeneratedProofs_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_CleanupGeneratedProofs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_CleanupGeneratedProofs_Call) Return(_a0 error) *StorageMock_CleanupGeneratedProofs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_CleanupGeneratedProofs_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) error) *StorageMock_CleanupGeneratedProofs_Call {
	_c.Call.Return(run)
	return _c
}

// CleanupLockedProofs provides a mock function with given fields: ctx, duration, dbTx
func (_m *StorageMock) CleanupLockedProofs(ctx context.Context, duration string, dbTx pgx.Tx) (int64, error) {
	ret := _m.Called(ctx, duration, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for CleanupLockedProofs")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, pgx.Tx) (int64, error)); ok {
		return rf(ctx, duration, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, pgx.Tx) int64); ok {
		r0 = rf(ctx, duration, dbTx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, pgx.Tx) error); ok {
		r1 = rf(ctx, duration, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_CleanupLockedProofs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanupLockedProofs'
type StorageMock_CleanupLockedProofs_Call struct {
	*mock.Call
}

// CleanupLockedProofs is a helper method to define mock.On call
//   - ctx context.Context
//   - duration string
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) CleanupLockedProofs(ctx interface{}, duration interface{}, dbTx interface{}) *StorageMock_CleanupLockedProofs_Call {
	return &StorageMock_CleanupLockedProofs_Call{Call: _e.mock.On("CleanupLockedProofs", ctx, duration, dbTx)}
}

func (_c *StorageMock_CleanupLockedProofs_Call) Run(run func(ctx context.Context, duration string, dbTx pgx.Tx)) *StorageMock_CleanupLockedProofs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_CleanupLockedProofs_Call) Return(_a0 int64, _a1 error) *StorageMock_CleanupLockedProofs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_CleanupLockedProofs_Call) RunAndReturn(run func(context.Context, string, pgx.Tx) (int64, error)) *StorageMock_CleanupLockedProofs_Call {
	_c.Call.Return(run)
	return _c
}

// CloseBatchInStorage provides a mock function with given fields: ctx, receipt, dbTx
func (_m *StorageMock) CloseBatchInStorage(ctx context.Context, receipt state.ProcessingReceipt, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, receipt, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for CloseBatchInStorage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.ProcessingReceipt, pgx.Tx) error); ok {
		r0 = rf(ctx, receipt, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_CloseBatchInStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloseBatchInStorage'
type StorageMock_CloseBatchInStorage_Call struct {
	*mock.Call
}

// CloseBatchInStorage is a helper method to define mock.On call
//   - ctx context.Context
//   - receipt state.ProcessingReceipt
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) CloseBatchInStorage(ctx interface{}, receipt interface{}, dbTx interface{}) *StorageMock_CloseBatchInStorage_Call {
	return &StorageMock_CloseBatchInStorage_Call{Call: _e.mock.On("CloseBatchInStorage", ctx, receipt, dbTx)}
}

func (_c *StorageMock_CloseBatchInStorage_Call) Run(run func(ctx context.Context, receipt state.ProcessingReceipt, dbTx pgx.Tx)) *StorageMock_CloseBatchInStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.ProcessingReceipt), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_CloseBatchInStorage_Call) Return(_a0 error) *StorageMock_CloseBatchInStorage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_CloseBatchInStorage_Call) RunAndReturn(run func(context.Context, state.ProcessingReceipt, pgx.Tx) error) *StorageMock_CloseBatchInStorage_Call {
	_c.Call.Return(run)
	return _c
}

// CloseWIPBatchInStorage provides a mock function with given fields: ctx, receipt, dbTx
func (_m *StorageMock) CloseWIPBatchInStorage(ctx context.Context, receipt state.ProcessingReceipt, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, receipt, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for CloseWIPBatchInStorage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.ProcessingReceipt, pgx.Tx) error); ok {
		r0 = rf(ctx, receipt, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_CloseWIPBatchInStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloseWIPBatchInStorage'
type StorageMock_CloseWIPBatchInStorage_Call struct {
	*mock.Call
}

// CloseWIPBatchInStorage is a helper method to define mock.On call
//   - ctx context.Context
//   - receipt state.ProcessingReceipt
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) CloseWIPBatchInStorage(ctx interface{}, receipt interface{}, dbTx interface{}) *StorageMock_CloseWIPBatchInStorage_Call {
	return &StorageMock_CloseWIPBatchInStorage_Call{Call: _e.mock.On("CloseWIPBatchInStorage", ctx, receipt, dbTx)}
}

func (_c *StorageMock_CloseWIPBatchInStorage_Call) Run(run func(ctx context.Context, receipt state.ProcessingReceipt, dbTx pgx.Tx)) *StorageMock_CloseWIPBatchInStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.ProcessingReceipt), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_CloseWIPBatchInStorage_Call) Return(_a0 error) *StorageMock_CloseWIPBatchInStorage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_CloseWIPBatchInStorage_Call) RunAndReturn(run func(context.Context, state.ProcessingReceipt, pgx.Tx) error) *StorageMock_CloseWIPBatchInStorage_Call {
	_c.Call.Return(run)
	return _c
}

// CountReorgs provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) CountReorgs(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for CountReorgs")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_CountReorgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountReorgs'
type StorageMock_CountReorgs_Call struct {
	*mock.Call
}

// CountReorgs is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) CountReorgs(ctx interface{}, dbTx interface{}) *StorageMock_CountReorgs_Call {
	return &StorageMock_CountReorgs_Call{Call: _e.mock.On("CountReorgs", ctx, dbTx)}
}

func (_c *StorageMock_CountReorgs_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_CountReorgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_CountReorgs_Call) Return(_a0 uint64, _a1 error) *StorageMock_CountReorgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_CountReorgs_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_CountReorgs_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGeneratedProofs provides a mock function with given fields: ctx, batchNumber, batchNumberFinal, dbTx
func (_m *StorageMock) DeleteGeneratedProofs(ctx context.Context, batchNumber uint64, batchNumberFinal uint64, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchNumber, batchNumberFinal, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGeneratedProofs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) error); ok {
		r0 = rf(ctx, batchNumber, batchNumberFinal, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_DeleteGeneratedProofs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGeneratedProofs'
type StorageMock_DeleteGeneratedProofs_Call struct {
	*mock.Call
}

// DeleteGeneratedProofs is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - batchNumberFinal uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) DeleteGeneratedProofs(ctx interface{}, batchNumber interface{}, batchNumberFinal interface{}, dbTx interface{}) *StorageMock_DeleteGeneratedProofs_Call {
	return &StorageMock_DeleteGeneratedProofs_Call{Call: _e.mock.On("DeleteGeneratedProofs", ctx, batchNumber, batchNumberFinal, dbTx)}
}

func (_c *StorageMock_DeleteGeneratedProofs_Call) Run(run func(ctx context.Context, batchNumber uint64, batchNumberFinal uint64, dbTx pgx.Tx)) *StorageMock_DeleteGeneratedProofs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_DeleteGeneratedProofs_Call) Return(_a0 error) *StorageMock_DeleteGeneratedProofs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_DeleteGeneratedProofs_Call) RunAndReturn(run func(context.Context, uint64, uint64, pgx.Tx) error) *StorageMock_DeleteGeneratedProofs_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUngeneratedProofs provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) DeleteUngeneratedProofs(ctx context.Context, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUngeneratedProofs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) error); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_DeleteUngeneratedProofs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUngeneratedProofs'
type StorageMock_DeleteUngeneratedProofs_Call struct {
	*mock.Call
}

// DeleteUngeneratedProofs is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) DeleteUngeneratedProofs(ctx interface{}, dbTx interface{}) *StorageMock_DeleteUngeneratedProofs_Call {
	return &StorageMock_DeleteUngeneratedProofs_Call{Call: _e.mock.On("DeleteUngeneratedProofs", ctx, dbTx)}
}

func (_c *StorageMock_DeleteUngeneratedProofs_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_DeleteUngeneratedProofs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_DeleteUngeneratedProofs_Call) Return(_a0 error) *StorageMock_DeleteUngeneratedProofs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_DeleteUngeneratedProofs_Call) RunAndReturn(run func(context.Context, pgx.Tx) error) *StorageMock_DeleteUngeneratedProofs_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: ctx, sql, arguments
func (_m *StorageMock) Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) {
	var _ca []interface{}
	_ca = append(_ca, ctx, sql)
	_ca = append(_ca, arguments...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 pgconn.CommandTag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (pgconn.CommandTag, error)); ok {
		return rf(ctx, sql, arguments...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgconn.CommandTag); ok {
		r0 = rf(ctx, sql, arguments...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgconn.CommandTag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok {
		r1 = rf(ctx, sql, arguments...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type StorageMock_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - arguments ...interface{}
func (_e *StorageMock_Expecter) Exec(ctx interface{}, sql interface{}, arguments ...interface{}) *StorageMock_Exec_Call {
	return &StorageMock_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{ctx, sql}, arguments...)...)}
}

func (_c *StorageMock_Exec_Call) Run(run func(ctx context.Context, sql string, arguments ...interface{})) *StorageMock_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *StorageMock_Exec_Call) Return(commandTag pgconn.CommandTag, err error) *StorageMock_Exec_Call {
	_c.Call.Return(commandTag, err)
	return _c
}

func (_c *StorageMock_Exec_Call) RunAndReturn(run func(context.Context, string, ...interface{}) (pgconn.CommandTag, error)) *StorageMock_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllL1InfoRootEntries provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetAllL1InfoRootEntries(ctx context.Context, dbTx pgx.Tx) ([]state.L1InfoTreeExitRootStorageEntry, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllL1InfoRootEntries")
	}

	var r0 []state.L1InfoTreeExitRootStorageEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) ([]state.L1InfoTreeExitRootStorageEntry, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) []state.L1InfoTreeExitRootStorageEntry); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]state.L1InfoTreeExitRootStorageEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetAllL1InfoRootEntries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllL1InfoRootEntries'
type StorageMock_GetAllL1InfoRootEntries_Call struct {
	*mock.Call
}

// GetAllL1InfoRootEntries is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetAllL1InfoRootEntries(ctx interface{}, dbTx interface{}) *StorageMock_GetAllL1InfoRootEntries_Call {
	return &StorageMock_GetAllL1InfoRootEntries_Call{Call: _e.mock.On("GetAllL1InfoRootEntries", ctx, dbTx)}
}

func (_c *StorageMock_GetAllL1InfoRootEntries_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetAllL1InfoRootEntries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetAllL1InfoRootEntries_Call) Return(_a0 []state.L1InfoTreeExitRootStorageEntry, _a1 error) *StorageMock_GetAllL1InfoRootEntries_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetAllL1InfoRootEntries_Call) RunAndReturn(run func(context.Context, pgx.Tx) ([]state.L1InfoTreeExitRootStorageEntry, error)) *StorageMock_GetAllL1InfoRootEntries_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchByForcedBatchNum provides a mock function with given fields: ctx, forcedBatchNumber, dbTx
func (_m *StorageMock) GetBatchByForcedBatchNum(ctx context.Context, forcedBatchNumber uint64, dbTx pgx.Tx) (*state.Batch, error) {
	ret := _m.Called(ctx, forcedBatchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchByForcedBatchNum")
	}

	var r0 *state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Batch, error)); ok {
		return rf(ctx, forcedBatchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Batch); ok {
		r0 = rf(ctx, forcedBatchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, forcedBatchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetBatchByForcedBatchNum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchByForcedBatchNum'
type StorageMock_GetBatchByForcedBatchNum_Call struct {
	*mock.Call
}

// GetBatchByForcedBatchNum is a helper method to define mock.On call
//   - ctx context.Context
//   - forcedBatchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetBatchByForcedBatchNum(ctx interface{}, forcedBatchNumber interface{}, dbTx interface{}) *StorageMock_GetBatchByForcedBatchNum_Call {
	return &StorageMock_GetBatchByForcedBatchNum_Call{Call: _e.mock.On("GetBatchByForcedBatchNum", ctx, forcedBatchNumber, dbTx)}
}

func (_c *StorageMock_GetBatchByForcedBatchNum_Call) Run(run func(ctx context.Context, forcedBatchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetBatchByForcedBatchNum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetBatchByForcedBatchNum_Call) Return(_a0 *state.Batch, _a1 error) *StorageMock_GetBatchByForcedBatchNum_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetBatchByForcedBatchNum_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Batch, error)) *StorageMock_GetBatchByForcedBatchNum_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchByL2BlockNumber provides a mock function with given fields: ctx, l2BlockNumber, dbTx
func (_m *StorageMock) GetBatchByL2BlockNumber(ctx context.Context, l2BlockNumber uint64, dbTx pgx.Tx) (*state.Batch, error) {
	ret := _m.Called(ctx, l2BlockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchByL2BlockNumber")
	}

	var r0 *state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Batch, error)); ok {
		return rf(ctx, l2BlockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Batch); ok {
		r0 = rf(ctx, l2BlockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, l2BlockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetBatchByL2BlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchByL2BlockNumber'
type StorageMock_GetBatchByL2BlockNumber_Call struct {
	*mock.Call
}

// GetBatchByL2BlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - l2BlockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetBatchByL2BlockNumber(ctx interface{}, l2BlockNumber interface{}, dbTx interface{}) *StorageMock_GetBatchByL2BlockNumber_Call {
	return &StorageMock_GetBatchByL2BlockNumber_Call{Call: _e.mock.On("GetBatchByL2BlockNumber", ctx, l2BlockNumber, dbTx)}
}

func (_c *StorageMock_GetBatchByL2BlockNumber_Call) Run(run func(ctx context.Context, l2BlockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetBatchByL2BlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetBatchByL2BlockNumber_Call) Return(_a0 *state.Batch, _a1 error) *StorageMock_GetBatchByL2BlockNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetBatchByL2BlockNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Batch, error)) *StorageMock_GetBatchByL2BlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchByNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetBatchByNumber(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (*state.Batch, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchByNumber")
	}

	var r0 *state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Batch, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Batch); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetBatchByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchByNumber'
type StorageMock_GetBatchByNumber_Call struct {
	*mock.Call
}

// GetBatchByNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetBatchByNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetBatchByNumber_Call {
	return &StorageMock_GetBatchByNumber_Call{Call: _e.mock.On("GetBatchByNumber", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetBatchByNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetBatchByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetBatchByNumber_Call) Return(_a0 *state.Batch, _a1 error) *StorageMock_GetBatchByNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetBatchByNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Batch, error)) *StorageMock_GetBatchByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchByTxHash provides a mock function with given fields: ctx, transactionHash, dbTx
func (_m *StorageMock) GetBatchByTxHash(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx) (*state.Batch, error) {
	ret := _m.Called(ctx, transactionHash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchByTxHash")
	}

	var r0 *state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*state.Batch, error)); ok {
		return rf(ctx, transactionHash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *state.Batch); ok {
		r0 = rf(ctx, transactionHash, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, transactionHash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetBatchByTxHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchByTxHash'
type StorageMock_GetBatchByTxHash_Call struct {
	*mock.Call
}

// GetBatchByTxHash is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionHash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetBatchByTxHash(ctx interface{}, transactionHash interface{}, dbTx interface{}) *StorageMock_GetBatchByTxHash_Call {
	return &StorageMock_GetBatchByTxHash_Call{Call: _e.mock.On("GetBatchByTxHash", ctx, transactionHash, dbTx)}
}

func (_c *StorageMock_GetBatchByTxHash_Call) Run(run func(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx)) *StorageMock_GetBatchByTxHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetBatchByTxHash_Call) Return(_a0 *state.Batch, _a1 error) *StorageMock_GetBatchByTxHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetBatchByTxHash_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*state.Batch, error)) *StorageMock_GetBatchByTxHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchNumberOfL2Block provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) GetBatchNumberOfL2Block(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchNumberOfL2Block")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) uint64); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetBatchNumberOfL2Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchNumberOfL2Block'
type StorageMock_GetBatchNumberOfL2Block_Call struct {
	*mock.Call
}

// GetBatchNumberOfL2Block is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetBatchNumberOfL2Block(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_GetBatchNumberOfL2Block_Call {
	return &StorageMock_GetBatchNumberOfL2Block_Call{Call: _e.mock.On("GetBatchNumberOfL2Block", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_GetBatchNumberOfL2Block_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetBatchNumberOfL2Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetBatchNumberOfL2Block_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetBatchNumberOfL2Block_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetBatchNumberOfL2Block_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (uint64, error)) *StorageMock_GetBatchNumberOfL2Block_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockByNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) GetBlockByNumber(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) (*state.Block, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockByNumber")
	}

	var r0 *state.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Block, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Block); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetBlockByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockByNumber'
type StorageMock_GetBlockByNumber_Call struct {
	*mock.Call
}

// GetBlockByNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetBlockByNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_GetBlockByNumber_Call {
	return &StorageMock_GetBlockByNumber_Call{Call: _e.mock.On("GetBlockByNumber", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_GetBlockByNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetBlockByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetBlockByNumber_Call) Return(_a0 *state.Block, _a1 error) *StorageMock_GetBlockByNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetBlockByNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Block, error)) *StorageMock_GetBlockByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockNumAndMainnetExitRootByGER provides a mock function with given fields: ctx, ger, dbTx
func (_m *StorageMock) GetBlockNumAndMainnetExitRootByGER(ctx context.Context, ger common.Hash, dbTx pgx.Tx) (uint64, common.Hash, error) {
	ret := _m.Called(ctx, ger, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockNumAndMainnetExitRootByGER")
	}

	var r0 uint64
	var r1 common.Hash
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (uint64, common.Hash, error)); ok {
		return rf(ctx, ger, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) uint64); ok {
		r0 = rf(ctx, ger, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) common.Hash); ok {
		r1 = rf(ctx, ger, dbTx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(common.Hash)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r2 = rf(ctx, ger, dbTx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageMock_GetBlockNumAndMainnetExitRootByGER_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockNumAndMainnetExitRootByGER'
type StorageMock_GetBlockNumAndMainnetExitRootByGER_Call struct {
	*mock.Call
}

// GetBlockNumAndMainnetExitRootByGER is a helper method to define mock.On call
//   - ctx context.Context
//   - ger common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetBlockNumAndMainnetExitRootByGER(ctx interface{}, ger interface{}, dbTx interface{}) *StorageMock_GetBlockNumAndMainnetExitRootByGER_Call {
	return &StorageMock_GetBlockNumAndMainnetExitRootByGER_Call{Call: _e.mock.On("GetBlockNumAndMainnetExitRootByGER", ctx, ger, dbTx)}
}

func (_c *StorageMock_GetBlockNumAndMainnetExitRootByGER_Call) Run(run func(ctx context.Context, ger common.Hash, dbTx pgx.Tx)) *StorageMock_GetBlockNumAndMainnetExitRootByGER_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetBlockNumAndMainnetExitRootByGER_Call) Return(_a0 uint64, _a1 common.Hash, _a2 error) *StorageMock_GetBlockNumAndMainnetExitRootByGER_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *StorageMock_GetBlockNumAndMainnetExitRootByGER_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (uint64, common.Hash, error)) *StorageMock_GetBlockNumAndMainnetExitRootByGER_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockNumVirtualBatchByBatchNum provides a mock function with given fields: ctx, batchNum, dbTx
func (_m *StorageMock) GetBlockNumVirtualBatchByBatchNum(ctx context.Context, batchNum uint64, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, batchNum, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockNumVirtualBatchByBatchNum")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, batchNum, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) uint64); ok {
		r0 = rf(ctx, batchNum, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNum, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetBlockNumVirtualBatchByBatchNum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockNumVirtualBatchByBatchNum'
type StorageMock_GetBlockNumVirtualBatchByBatchNum_Call struct {
	*mock.Call
}

// GetBlockNumVirtualBatchByBatchNum is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNum uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetBlockNumVirtualBatchByBatchNum(ctx interface{}, batchNum interface{}, dbTx interface{}) *StorageMock_GetBlockNumVirtualBatchByBatchNum_Call {
	return &StorageMock_GetBlockNumVirtualBatchByBatchNum_Call{Call: _e.mock.On("GetBlockNumVirtualBatchByBatchNum", ctx, batchNum, dbTx)}
}

func (_c *StorageMock_GetBlockNumVirtualBatchByBatchNum_Call) Run(run func(ctx context.Context, batchNum uint64, dbTx pgx.Tx)) *StorageMock_GetBlockNumVirtualBatchByBatchNum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetBlockNumVirtualBatchByBatchNum_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetBlockNumVirtualBatchByBatchNum_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetBlockNumVirtualBatchByBatchNum_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (uint64, error)) *StorageMock_GetBlockNumVirtualBatchByBatchNum_Call {
	_c.Call.Return(run)
	return _c
}

// GetDSBatches provides a mock function with given fields: ctx, firstBatchNumber, lastBatchNumber, readWIPBatch, dbTx
func (_m *StorageMock) GetDSBatches(ctx context.Context, firstBatchNumber uint64, lastBatchNumber uint64, readWIPBatch bool, dbTx pgx.Tx) ([]*state.DSBatch, error) {
	ret := _m.Called(ctx, firstBatchNumber, lastBatchNumber, readWIPBatch, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDSBatches")
	}

	var r0 []*state.DSBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, bool, pgx.Tx) ([]*state.DSBatch, error)); ok {
		return rf(ctx, firstBatchNumber, lastBatchNumber, readWIPBatch, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, bool, pgx.Tx) []*state.DSBatch); ok {
		r0 = rf(ctx, firstBatchNumber, lastBatchNumber, readWIPBatch, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.DSBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, bool, pgx.Tx) error); ok {
		r1 = rf(ctx, firstBatchNumber, lastBatchNumber, readWIPBatch, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetDSBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDSBatches'
type StorageMock_GetDSBatches_Call struct {
	*mock.Call
}

// GetDSBatches is a helper method to define mock.On call
//   - ctx context.Context
//   - firstBatchNumber uint64
//   - lastBatchNumber uint64
//   - readWIPBatch bool
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetDSBatches(ctx interface{}, firstBatchNumber interface{}, lastBatchNumber interface{}, readWIPBatch interface{}, dbTx interface{}) *StorageMock_GetDSBatches_Call {
	return &StorageMock_GetDSBatches_Call{Call: _e.mock.On("GetDSBatches", ctx, firstBatchNumber, lastBatchNumber, readWIPBatch, dbTx)}
}

func (_c *StorageMock_GetDSBatches_Call) Run(run func(ctx context.Context, firstBatchNumber uint64, lastBatchNumber uint64, readWIPBatch bool, dbTx pgx.Tx)) *StorageMock_GetDSBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(bool), args[4].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetDSBatches_Call) Return(_a0 []*state.DSBatch, _a1 error) *StorageMock_GetDSBatches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetDSBatches_Call) RunAndReturn(run func(context.Context, uint64, uint64, bool, pgx.Tx) ([]*state.DSBatch, error)) *StorageMock_GetDSBatches_Call {
	_c.Call.Return(run)
	return _c
}

// GetDSGenesisBlock provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetDSGenesisBlock(ctx context.Context, dbTx pgx.Tx) (*state.DSL2Block, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDSGenesisBlock")
	}

	var r0 *state.DSL2Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*state.DSL2Block, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *state.DSL2Block); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.DSL2Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetDSGenesisBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDSGenesisBlock'
type StorageMock_GetDSGenesisBlock_Call struct {
	*mock.Call
}

// GetDSGenesisBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetDSGenesisBlock(ctx interface{}, dbTx interface{}) *StorageMock_GetDSGenesisBlock_Call {
	return &StorageMock_GetDSGenesisBlock_Call{Call: _e.mock.On("GetDSGenesisBlock", ctx, dbTx)}
}

func (_c *StorageMock_GetDSGenesisBlock_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetDSGenesisBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetDSGenesisBlock_Call) Return(_a0 *state.DSL2Block, _a1 error) *StorageMock_GetDSGenesisBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetDSGenesisBlock_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*state.DSL2Block, error)) *StorageMock_GetDSGenesisBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetDSL2Blocks provides a mock function with given fields: ctx, firstBatchNumber, lastBatchNumber, dbTx
func (_m *StorageMock) GetDSL2Blocks(ctx context.Context, firstBatchNumber uint64, lastBatchNumber uint64, dbTx pgx.Tx) ([]*state.DSL2Block, error) {
	ret := _m.Called(ctx, firstBatchNumber, lastBatchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDSL2Blocks")
	}

	var r0 []*state.DSL2Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) ([]*state.DSL2Block, error)); ok {
		return rf(ctx, firstBatchNumber, lastBatchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) []*state.DSL2Block); ok {
		r0 = rf(ctx, firstBatchNumber, lastBatchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.DSL2Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, firstBatchNumber, lastBatchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetDSL2Blocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDSL2Blocks'
type StorageMock_GetDSL2Blocks_Call struct {
	*mock.Call
}

// GetDSL2Blocks is a helper method to define mock.On call
//   - ctx context.Context
//   - firstBatchNumber uint64
//   - lastBatchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetDSL2Blocks(ctx interface{}, firstBatchNumber interface{}, lastBatchNumber interface{}, dbTx interface{}) *StorageMock_GetDSL2Blocks_Call {
	return &StorageMock_GetDSL2Blocks_Call{Call: _e.mock.On("GetDSL2Blocks", ctx, firstBatchNumber, lastBatchNumber, dbTx)}
}

func (_c *StorageMock_GetDSL2Blocks_Call) Run(run func(ctx context.Context, firstBatchNumber uint64, lastBatchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetDSL2Blocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetDSL2Blocks_Call) Return(_a0 []*state.DSL2Block, _a1 error) *StorageMock_GetDSL2Blocks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetDSL2Blocks_Call) RunAndReturn(run func(context.Context, uint64, uint64, pgx.Tx) ([]*state.DSL2Block, error)) *StorageMock_GetDSL2Blocks_Call {
	_c.Call.Return(run)
	return _c
}

// GetDSL2Transactions provides a mock function with given fields: ctx, firstL2Block, lastL2Block, dbTx
func (_m *StorageMock) GetDSL2Transactions(ctx context.Context, firstL2Block uint64, lastL2Block uint64, dbTx pgx.Tx) ([]*state.DSL2Transaction, error) {
	ret := _m.Called(ctx, firstL2Block, lastL2Block, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDSL2Transactions")
	}

	var r0 []*state.DSL2Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) ([]*state.DSL2Transaction, error)); ok {
		return rf(ctx, firstL2Block, lastL2Block, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) []*state.DSL2Transaction); ok {
		r0 = rf(ctx, firstL2Block, lastL2Block, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.DSL2Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, firstL2Block, lastL2Block, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetDSL2Transactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDSL2Transactions'
type StorageMock_GetDSL2Transactions_Call struct {
	*mock.Call
}

// GetDSL2Transactions is a helper method to define mock.On call
//   - ctx context.Context
//   - firstL2Block uint64
//   - lastL2Block uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetDSL2Transactions(ctx interface{}, firstL2Block interface{}, lastL2Block interface{}, dbTx interface{}) *StorageMock_GetDSL2Transactions_Call {
	return &StorageMock_GetDSL2Transactions_Call{Call: _e.mock.On("GetDSL2Transactions", ctx, firstL2Block, lastL2Block, dbTx)}
}

func (_c *StorageMock_GetDSL2Transactions_Call) Run(run func(ctx context.Context, firstL2Block uint64, lastL2Block uint64, dbTx pgx.Tx)) *StorageMock_GetDSL2Transactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetDSL2Transactions_Call) Return(_a0 []*state.DSL2Transaction, _a1 error) *StorageMock_GetDSL2Transactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetDSL2Transactions_Call) RunAndReturn(run func(context.Context, uint64, uint64, pgx.Tx) ([]*state.DSL2Transaction, error)) *StorageMock_GetDSL2Transactions_Call {
	_c.Call.Return(run)
	return _c
}

// GetEncodedTransactionsByBatchNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetEncodedTransactionsByBatchNumber(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) ([]string, []uint8, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetEncodedTransactionsByBatchNumber")
	}

	var r0 []string
	var r1 []uint8
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]string, []uint8, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []string); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) []uint8); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]uint8)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64, pgx.Tx) error); ok {
		r2 = rf(ctx, batchNumber, dbTx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageMock_GetEncodedTransactionsByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEncodedTransactionsByBatchNumber'
type StorageMock_GetEncodedTransactionsByBatchNumber_Call struct {
	*mock.Call
}

// GetEncodedTransactionsByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetEncodedTransactionsByBatchNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetEncodedTransactionsByBatchNumber_Call {
	return &StorageMock_GetEncodedTransactionsByBatchNumber_Call{Call: _e.mock.On("GetEncodedTransactionsByBatchNumber", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetEncodedTransactionsByBatchNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetEncodedTransactionsByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetEncodedTransactionsByBatchNumber_Call) Return(encodedTxs []string, effectivePercentages []uint8, err error) *StorageMock_GetEncodedTransactionsByBatchNumber_Call {
	_c.Call.Return(encodedTxs, effectivePercentages, err)
	return _c
}

func (_c *StorageMock_GetEncodedTransactionsByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]string, []uint8, error)) *StorageMock_GetEncodedTransactionsByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetExitRootByGlobalExitRoot provides a mock function with given fields: ctx, ger, dbTx
func (_m *StorageMock) GetExitRootByGlobalExitRoot(ctx context.Context, ger common.Hash, dbTx pgx.Tx) (*state.GlobalExitRoot, error) {
	ret := _m.Called(ctx, ger, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetExitRootByGlobalExitRoot")
	}

	var r0 *state.GlobalExitRoot
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*state.GlobalExitRoot, error)); ok {
		return rf(ctx, ger, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *state.GlobalExitRoot); ok {
		r0 = rf(ctx, ger, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.GlobalExitRoot)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, ger, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetExitRootByGlobalExitRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExitRootByGlobalExitRoot'
type StorageMock_GetExitRootByGlobalExitRoot_Call struct {
	*mock.Call
}

// GetExitRootByGlobalExitRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - ger common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetExitRootByGlobalExitRoot(ctx interface{}, ger interface{}, dbTx interface{}) *StorageMock_GetExitRootByGlobalExitRoot_Call {
	return &StorageMock_GetExitRootByGlobalExitRoot_Call{Call: _e.mock.On("GetExitRootByGlobalExitRoot", ctx, ger, dbTx)}
}

func (_c *StorageMock_GetExitRootByGlobalExitRoot_Call) Run(run func(ctx context.Context, ger common.Hash, dbTx pgx.Tx)) *StorageMock_GetExitRootByGlobalExitRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetExitRootByGlobalExitRoot_Call) Return(_a0 *state.GlobalExitRoot, _a1 error) *StorageMock_GetExitRootByGlobalExitRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetExitRootByGlobalExitRoot_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*state.GlobalExitRoot, error)) *StorageMock_GetExitRootByGlobalExitRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetForcedBatch provides a mock function with given fields: ctx, forcedBatchNumber, dbTx
func (_m *StorageMock) GetForcedBatch(ctx context.Context, forcedBatchNumber uint64, dbTx pgx.Tx) (*state.ForcedBatch, error) {
	ret := _m.Called(ctx, forcedBatchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetForcedBatch")
	}

	var r0 *state.ForcedBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.ForcedBatch, error)); ok {
		return rf(ctx, forcedBatchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.ForcedBatch); ok {
		r0 = rf(ctx, forcedBatchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.ForcedBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, forcedBatchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetForcedBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForcedBatch'
type StorageMock_GetForcedBatch_Call struct {
	*mock.Call
}

// GetForcedBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - forcedBatchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetForcedBatch(ctx interface{}, forcedBatchNumber interface{}, dbTx interface{}) *StorageMock_GetForcedBatch_Call {
	return &StorageMock_GetForcedBatch_Call{Call: _e.mock.On("GetForcedBatch", ctx, forcedBatchNumber, dbTx)}
}

func (_c *StorageMock_GetForcedBatch_Call) Run(run func(ctx context.Context, forcedBatchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetForcedBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetForcedBatch_Call) Return(_a0 *state.ForcedBatch, _a1 error) *StorageMock_GetForcedBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetForcedBatch_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.ForcedBatch, error)) *StorageMock_GetForcedBatch_Call {
	_c.Call.Return(run)
	return _c
}

// GetForcedBatchParentHash provides a mock function with given fields: ctx, forcedBatchNumber, dbTx
func (_m *StorageMock) GetForcedBatchParentHash(ctx context.Context, forcedBatchNumber uint64, dbTx pgx.Tx) (common.Hash, error) {
	ret := _m.Called(ctx, forcedBatchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetForcedBatchParentHash")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (common.Hash, error)); ok {
		return rf(ctx, forcedBatchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) common.Hash); ok {
		r0 = rf(ctx, forcedBatchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, forcedBatchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetForcedBatchParentHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForcedBatchParentHash'
type StorageMock_GetForcedBatchParentHash_Call struct {
	*mock.Call
}

// GetForcedBatchParentHash is a helper method to define mock.On call
//   - ctx context.Context
//   - forcedBatchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetForcedBatchParentHash(ctx interface{}, forcedBatchNumber interface{}, dbTx interface{}) *StorageMock_GetForcedBatchParentHash_Call {
	return &StorageMock_GetForcedBatchParentHash_Call{Call: _e.mock.On("GetForcedBatchParentHash", ctx, forcedBatchNumber, dbTx)}
}

func (_c *StorageMock_GetForcedBatchParentHash_Call) Run(run func(ctx context.Context, forcedBatchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetForcedBatchParentHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetForcedBatchParentHash_Call) Return(_a0 common.Hash, _a1 error) *StorageMock_GetForcedBatchParentHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetForcedBatchParentHash_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (common.Hash, error)) *StorageMock_GetForcedBatchParentHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetForcedBatchesSince provides a mock function with given fields: ctx, forcedBatchNumber, maxBlockNumber, dbTx
func (_m *StorageMock) GetForcedBatchesSince(ctx context.Context, forcedBatchNumber uint64, maxBlockNumber uint64, dbTx pgx.Tx) ([]*state.ForcedBatch, error) {
	ret := _m.Called(ctx, forcedBatchNumber, maxBlockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetForcedBatchesSince")
	}

	var r0 []*state.ForcedBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) ([]*state.ForcedBatch, error)); ok {
		return rf(ctx, forcedBatchNumber, maxBlockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) []*state.ForcedBatch); ok {
		r0 = rf(ctx, forcedBatchNumber, maxBlockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.ForcedBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, forcedBatchNumber, maxBlockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetForcedBatchesSince_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForcedBatchesSince'
type StorageMock_GetForcedBatchesSince_Call struct {
	*mock.Call
}

// GetForcedBatchesSince is a helper method to define mock.On call
//   - ctx context.Context
//   - forcedBatchNumber uint64
//   - maxBlockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetForcedBatchesSince(ctx interface{}, forcedBatchNumber interface{}, maxBlockNumber interface{}, dbTx interface{}) *StorageMock_GetForcedBatchesSince_Call {
	return &StorageMock_GetForcedBatchesSince_Call{Call: _e.mock.On("GetForcedBatchesSince", ctx, forcedBatchNumber, maxBlockNumber, dbTx)}
}

func (_c *StorageMock_GetForcedBatchesSince_Call) Run(run func(ctx context.Context, forcedBatchNumber uint64, maxBlockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetForcedBatchesSince_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetForcedBatchesSince_Call) Return(_a0 []*state.ForcedBatch, _a1 error) *StorageMock_GetForcedBatchesSince_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetForcedBatchesSince_Call) RunAndReturn(run func(context.Context, uint64, uint64, pgx.Tx) ([]*state.ForcedBatch, error)) *StorageMock_GetForcedBatchesSince_Call {
	_c.Call.Return(run)
	return _c
}

// GetForkIDByBatchNumber provides a mock function with given fields: batchNumber
func (_m *StorageMock) GetForkIDByBatchNumber(batchNumber uint64) uint64 {
	ret := _m.Called(batchNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetForkIDByBatchNumber")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func(uint64) uint64); ok {
		r0 = rf(batchNumber)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// StorageMock_GetForkIDByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForkIDByBatchNumber'
type StorageMock_GetForkIDByBatchNumber_Call struct {
	*mock.Call
}

// GetForkIDByBatchNumber is a helper method to define mock.On call
//   - batchNumber uint64
func (_e *StorageMock_Expecter) GetForkIDByBatchNumber(batchNumber interface{}) *StorageMock_GetForkIDByBatchNumber_Call {
	return &StorageMock_GetForkIDByBatchNumber_Call{Call: _e.mock.On("GetForkIDByBatchNumber", batchNumber)}
}

func (_c *StorageMock_GetForkIDByBatchNumber_Call) Run(run func(batchNumber uint64)) *StorageMock_GetForkIDByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *StorageMock_GetForkIDByBatchNumber_Call) Return(_a0 uint64) *StorageMock_GetForkIDByBatchNumber_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_GetForkIDByBatchNumber_Call) RunAndReturn(run func(uint64) uint64) *StorageMock_GetForkIDByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetForkIDByBlockNumber provides a mock function with given fields: blockNumber
func (_m *StorageMock) GetForkIDByBlockNumber(blockNumber uint64) uint64 {
	ret := _m.Called(blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetForkIDByBlockNumber")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func(uint64) uint64); ok {
		r0 = rf(blockNumber)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// StorageMock_GetForkIDByBlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForkIDByBlockNumber'
type StorageMock_GetForkIDByBlockNumber_Call struct {
	*mock.Call
}

// GetForkIDByBlockNumber is a helper method to define mock.On call
//   - blockNumber uint64
func (_e *StorageMock_Expecter) GetForkIDByBlockNumber(blockNumber interface{}) *StorageMock_GetForkIDByBlockNumber_Call {
	return &StorageMock_GetForkIDByBlockNumber_Call{Call: _e.mock.On("GetForkIDByBlockNumber", blockNumber)}
}

func (_c *StorageMock_GetForkIDByBlockNumber_Call) Run(run func(blockNumber uint64)) *StorageMock_GetForkIDByBlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *StorageMock_GetForkIDByBlockNumber_Call) Return(_a0 uint64) *StorageMock_GetForkIDByBlockNumber_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_GetForkIDByBlockNumber_Call) RunAndReturn(run func(uint64) uint64) *StorageMock_GetForkIDByBlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetForkIDs provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetForkIDs(ctx context.Context, dbTx pgx.Tx) ([]state.ForkIDInterval, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetForkIDs")
	}

	var r0 []state.ForkIDInterval
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) ([]state.ForkIDInterval, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) []state.ForkIDInterval); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]state.ForkIDInterval)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetForkIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForkIDs'
type StorageMock_GetForkIDs_Call struct {
	*mock.Call
}

// GetForkIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetForkIDs(ctx interface{}, dbTx interface{}) *StorageMock_GetForkIDs_Call {
	return &StorageMock_GetForkIDs_Call{Call: _e.mock.On("GetForkIDs", ctx, dbTx)}
}

func (_c *StorageMock_GetForkIDs_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetForkIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetForkIDs_Call) Return(_a0 []state.ForkIDInterval, _a1 error) *StorageMock_GetForkIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetForkIDs_Call) RunAndReturn(run func(context.Context, pgx.Tx) ([]state.ForkIDInterval, error)) *StorageMock_GetForkIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetL1InfoRootLeafByIndex provides a mock function with given fields: ctx, l1InfoTreeIndex, dbTx
func (_m *StorageMock) GetL1InfoRootLeafByIndex(ctx context.Context, l1InfoTreeIndex uint32, dbTx pgx.Tx) (state.L1InfoTreeExitRootStorageEntry, error) {
	ret := _m.Called(ctx, l1InfoTreeIndex, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL1InfoRootLeafByIndex")
	}

	var r0 state.L1InfoTreeExitRootStorageEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, pgx.Tx) (state.L1InfoTreeExitRootStorageEntry, error)); ok {
		return rf(ctx, l1InfoTreeIndex, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, pgx.Tx) state.L1InfoTreeExitRootStorageEntry); ok {
		r0 = rf(ctx, l1InfoTreeIndex, dbTx)
	} else {
		r0 = ret.Get(0).(state.L1InfoTreeExitRootStorageEntry)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, pgx.Tx) error); ok {
		r1 = rf(ctx, l1InfoTreeIndex, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL1InfoRootLeafByIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL1InfoRootLeafByIndex'
type StorageMock_GetL1InfoRootLeafByIndex_Call struct {
	*mock.Call
}

// GetL1InfoRootLeafByIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - l1InfoTreeIndex uint32
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL1InfoRootLeafByIndex(ctx interface{}, l1InfoTreeIndex interface{}, dbTx interface{}) *StorageMock_GetL1InfoRootLeafByIndex_Call {
	return &StorageMock_GetL1InfoRootLeafByIndex_Call{Call: _e.mock.On("GetL1InfoRootLeafByIndex", ctx, l1InfoTreeIndex, dbTx)}
}

func (_c *StorageMock_GetL1InfoRootLeafByIndex_Call) Run(run func(ctx context.Context, l1InfoTreeIndex uint32, dbTx pgx.Tx)) *StorageMock_GetL1InfoRootLeafByIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL1InfoRootLeafByIndex_Call) Return(_a0 state.L1InfoTreeExitRootStorageEntry, _a1 error) *StorageMock_GetL1InfoRootLeafByIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL1InfoRootLeafByIndex_Call) RunAndReturn(run func(context.Context, uint32, pgx.Tx) (state.L1InfoTreeExitRootStorageEntry, error)) *StorageMock_GetL1InfoRootLeafByIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetL1InfoRootLeafByL1InfoRoot provides a mock function with given fields: ctx, l1InfoRoot, dbTx
func (_m *StorageMock) GetL1InfoRootLeafByL1InfoRoot(ctx context.Context, l1InfoRoot common.Hash, dbTx pgx.Tx) (state.L1InfoTreeExitRootStorageEntry, error) {
	ret := _m.Called(ctx, l1InfoRoot, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL1InfoRootLeafByL1InfoRoot")
	}

	var r0 state.L1InfoTreeExitRootStorageEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (state.L1InfoTreeExitRootStorageEntry, error)); ok {
		return rf(ctx, l1InfoRoot, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) state.L1InfoTreeExitRootStorageEntry); ok {
		r0 = rf(ctx, l1InfoRoot, dbTx)
	} else {
		r0 = ret.Get(0).(state.L1InfoTreeExitRootStorageEntry)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, l1InfoRoot, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL1InfoRootLeafByL1InfoRoot'
type StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call struct {
	*mock.Call
}

// GetL1InfoRootLeafByL1InfoRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - l1InfoRoot common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL1InfoRootLeafByL1InfoRoot(ctx interface{}, l1InfoRoot interface{}, dbTx interface{}) *StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call {
	return &StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call{Call: _e.mock.On("GetL1InfoRootLeafByL1InfoRoot", ctx, l1InfoRoot, dbTx)}
}

func (_c *StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call) Run(run func(ctx context.Context, l1InfoRoot common.Hash, dbTx pgx.Tx)) *StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call) Return(_a0 state.L1InfoTreeExitRootStorageEntry, _a1 error) *StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (state.L1InfoTreeExitRootStorageEntry, error)) *StorageMock_GetL1InfoRootLeafByL1InfoRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetL2BlockByHash provides a mock function with given fields: ctx, hash, dbTx
func (_m *StorageMock) GetL2BlockByHash(ctx context.Context, hash common.Hash, dbTx pgx.Tx) (*state.L2Block, error) {
	ret := _m.Called(ctx, hash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL2BlockByHash")
	}

	var r0 *state.L2Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*state.L2Block, error)); ok {
		return rf(ctx, hash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *state.L2Block); ok {
		r0 = rf(ctx, hash, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.L2Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, hash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL2BlockByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL2BlockByHash'
type StorageMock_GetL2BlockByHash_Call struct {
	*mock.Call
}

// GetL2BlockByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL2BlockByHash(ctx interface{}, hash interface{}, dbTx interface{}) *StorageMock_GetL2BlockByHash_Call {
	return &StorageMock_GetL2BlockByHash_Call{Call: _e.mock.On("GetL2BlockByHash", ctx, hash, dbTx)}
}

func (_c *StorageMock_GetL2BlockByHash_Call) Run(run func(ctx context.Context, hash common.Hash, dbTx pgx.Tx)) *StorageMock_GetL2BlockByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL2BlockByHash_Call) Return(_a0 *state.L2Block, _a1 error) *StorageMock_GetL2BlockByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL2BlockByHash_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*state.L2Block, error)) *StorageMock_GetL2BlockByHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetL2BlockByNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) GetL2BlockByNumber(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) (*state.L2Block, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL2BlockByNumber")
	}

	var r0 *state.L2Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.L2Block, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.L2Block); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.L2Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL2BlockByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL2BlockByNumber'
type StorageMock_GetL2BlockByNumber_Call struct {
	*mock.Call
}

// GetL2BlockByNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL2BlockByNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_GetL2BlockByNumber_Call {
	return &StorageMock_GetL2BlockByNumber_Call{Call: _e.mock.On("GetL2BlockByNumber", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_GetL2BlockByNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetL2BlockByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL2BlockByNumber_Call) Return(_a0 *state.L2Block, _a1 error) *StorageMock_GetL2BlockByNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL2BlockByNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.L2Block, error)) *StorageMock_GetL2BlockByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetL2BlockHashesSince provides a mock function with given fields: ctx, since, dbTx
func (_m *StorageMock) GetL2BlockHashesSince(ctx context.Context, since time.Time, dbTx pgx.Tx) ([]common.Hash, error) {
	ret := _m.Called(ctx, since, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL2BlockHashesSince")
	}

	var r0 []common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, pgx.Tx) ([]common.Hash, error)); ok {
		return rf(ctx, since, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, pgx.Tx) []common.Hash); ok {
		r0 = rf(ctx, since, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time, pgx.Tx) error); ok {
		r1 = rf(ctx, since, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL2BlockHashesSince_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL2BlockHashesSince'
type StorageMock_GetL2BlockHashesSince_Call struct {
	*mock.Call
}

// GetL2BlockHashesSince is a helper method to define mock.On call
//   - ctx context.Context
//   - since time.Time
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL2BlockHashesSince(ctx interface{}, since interface{}, dbTx interface{}) *StorageMock_GetL2BlockHashesSince_Call {
	return &StorageMock_GetL2BlockHashesSince_Call{Call: _e.mock.On("GetL2BlockHashesSince", ctx, since, dbTx)}
}

func (_c *StorageMock_GetL2BlockHashesSince_Call) Run(run func(ctx context.Context, since time.Time, dbTx pgx.Tx)) *StorageMock_GetL2BlockHashesSince_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL2BlockHashesSince_Call) Return(_a0 []common.Hash, _a1 error) *StorageMock_GetL2BlockHashesSince_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL2BlockHashesSince_Call) RunAndReturn(run func(context.Context, time.Time, pgx.Tx) ([]common.Hash, error)) *StorageMock_GetL2BlockHashesSince_Call {
	_c.Call.Return(run)
	return _c
}

// GetL2BlockHeaderByHash provides a mock function with given fields: ctx, hash, dbTx
func (_m *StorageMock) GetL2BlockHeaderByHash(ctx context.Context, hash common.Hash, dbTx pgx.Tx) (*state.L2Header, error) {
	ret := _m.Called(ctx, hash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL2BlockHeaderByHash")
	}

	var r0 *state.L2Header
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*state.L2Header, error)); ok {
		return rf(ctx, hash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *state.L2Header); ok {
		r0 = rf(ctx, hash, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.L2Header)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, hash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL2BlockHeaderByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL2BlockHeaderByHash'
type StorageMock_GetL2BlockHeaderByHash_Call struct {
	*mock.Call
}

// GetL2BlockHeaderByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL2BlockHeaderByHash(ctx interface{}, hash interface{}, dbTx interface{}) *StorageMock_GetL2BlockHeaderByHash_Call {
	return &StorageMock_GetL2BlockHeaderByHash_Call{Call: _e.mock.On("GetL2BlockHeaderByHash", ctx, hash, dbTx)}
}

func (_c *StorageMock_GetL2BlockHeaderByHash_Call) Run(run func(ctx context.Context, hash common.Hash, dbTx pgx.Tx)) *StorageMock_GetL2BlockHeaderByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL2BlockHeaderByHash_Call) Return(_a0 *state.L2Header, _a1 error) *StorageMock_GetL2BlockHeaderByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL2BlockHeaderByHash_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*state.L2Header, error)) *StorageMock_GetL2BlockHeaderByHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetL2BlockHeaderByNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) GetL2BlockHeaderByNumber(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) (*state.L2Header, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL2BlockHeaderByNumber")
	}

	var r0 *state.L2Header
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.L2Header, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.L2Header); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.L2Header)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL2BlockHeaderByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL2BlockHeaderByNumber'
type StorageMock_GetL2BlockHeaderByNumber_Call struct {
	*mock.Call
}

// GetL2BlockHeaderByNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL2BlockHeaderByNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_GetL2BlockHeaderByNumber_Call {
	return &StorageMock_GetL2BlockHeaderByNumber_Call{Call: _e.mock.On("GetL2BlockHeaderByNumber", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_GetL2BlockHeaderByNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetL2BlockHeaderByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL2BlockHeaderByNumber_Call) Return(_a0 *state.L2Header, _a1 error) *StorageMock_GetL2BlockHeaderByNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL2BlockHeaderByNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.L2Header, error)) *StorageMock_GetL2BlockHeaderByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetL2BlockTransactionCountByHash provides a mock function with given fields: ctx, blockHash, dbTx
func (_m *StorageMock) GetL2BlockTransactionCountByHash(ctx context.Context, blockHash common.Hash, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, blockHash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL2BlockTransactionCountByHash")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, blockHash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) uint64); ok {
		r0 = rf(ctx, blockHash, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, blockHash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL2BlockTransactionCountByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL2BlockTransactionCountByHash'
type StorageMock_GetL2BlockTransactionCountByHash_Call struct {
	*mock.Call
}

// GetL2BlockTransactionCountByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - blockHash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL2BlockTransactionCountByHash(ctx interface{}, blockHash interface{}, dbTx interface{}) *StorageMock_GetL2BlockTransactionCountByHash_Call {
	return &StorageMock_GetL2BlockTransactionCountByHash_Call{Call: _e.mock.On("GetL2BlockTransactionCountByHash", ctx, blockHash, dbTx)}
}

func (_c *StorageMock_GetL2BlockTransactionCountByHash_Call) Run(run func(ctx context.Context, blockHash common.Hash, dbTx pgx.Tx)) *StorageMock_GetL2BlockTransactionCountByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL2BlockTransactionCountByHash_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetL2BlockTransactionCountByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL2BlockTransactionCountByHash_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (uint64, error)) *StorageMock_GetL2BlockTransactionCountByHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetL2BlockTransactionCountByNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) GetL2BlockTransactionCountByNumber(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL2BlockTransactionCountByNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) uint64); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL2BlockTransactionCountByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL2BlockTransactionCountByNumber'
type StorageMock_GetL2BlockTransactionCountByNumber_Call struct {
	*mock.Call
}

// GetL2BlockTransactionCountByNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL2BlockTransactionCountByNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_GetL2BlockTransactionCountByNumber_Call {
	return &StorageMock_GetL2BlockTransactionCountByNumber_Call{Call: _e.mock.On("GetL2BlockTransactionCountByNumber", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_GetL2BlockTransactionCountByNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetL2BlockTransactionCountByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL2BlockTransactionCountByNumber_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetL2BlockTransactionCountByNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL2BlockTransactionCountByNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (uint64, error)) *StorageMock_GetL2BlockTransactionCountByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetL2BlocksByBatchNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetL2BlocksByBatchNumber(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) ([]state.L2Block, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetL2BlocksByBatchNumber")
	}

	var r0 []state.L2Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]state.L2Block, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []state.L2Block); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]state.L2Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetL2BlocksByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetL2BlocksByBatchNumber'
type StorageMock_GetL2BlocksByBatchNumber_Call struct {
	*mock.Call
}

// GetL2BlocksByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetL2BlocksByBatchNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetL2BlocksByBatchNumber_Call {
	return &StorageMock_GetL2BlocksByBatchNumber_Call{Call: _e.mock.On("GetL2BlocksByBatchNumber", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetL2BlocksByBatchNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetL2BlocksByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetL2BlocksByBatchNumber_Call) Return(_a0 []state.L2Block, _a1 error) *StorageMock_GetL2BlocksByBatchNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetL2BlocksByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]state.L2Block, error)) *StorageMock_GetL2BlocksByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastBatchNumber provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastBatchNumber(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastBatchNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastBatchNumber'
type StorageMock_GetLastBatchNumber_Call struct {
	*mock.Call
}

// GetLastBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastBatchNumber(ctx interface{}, dbTx interface{}) *StorageMock_GetLastBatchNumber_Call {
	return &StorageMock_GetLastBatchNumber_Call{Call: _e.mock.On("GetLastBatchNumber", ctx, dbTx)}
}

func (_c *StorageMock_GetLastBatchNumber_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastBatchNumber_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastBatchNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastBatchNumber_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_GetLastBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastBatchTime provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastBatchTime(ctx context.Context, dbTx pgx.Tx) (time.Time, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastBatchTime")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (time.Time, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) time.Time); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastBatchTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastBatchTime'
type StorageMock_GetLastBatchTime_Call struct {
	*mock.Call
}

// GetLastBatchTime is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastBatchTime(ctx interface{}, dbTx interface{}) *StorageMock_GetLastBatchTime_Call {
	return &StorageMock_GetLastBatchTime_Call{Call: _e.mock.On("GetLastBatchTime", ctx, dbTx)}
}

func (_c *StorageMock_GetLastBatchTime_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastBatchTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastBatchTime_Call) Return(_a0 time.Time, _a1 error) *StorageMock_GetLastBatchTime_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastBatchTime_Call) RunAndReturn(run func(context.Context, pgx.Tx) (time.Time, error)) *StorageMock_GetLastBatchTime_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastBlock provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastBlock(ctx context.Context, dbTx pgx.Tx) (*state.Block, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastBlock")
	}

	var r0 *state.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*state.Block, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *state.Block); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastBlock'
type StorageMock_GetLastBlock_Call struct {
	*mock.Call
}

// GetLastBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastBlock(ctx interface{}, dbTx interface{}) *StorageMock_GetLastBlock_Call {
	return &StorageMock_GetLastBlock_Call{Call: _e.mock.On("GetLastBlock", ctx, dbTx)}
}

func (_c *StorageMock_GetLastBlock_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastBlock_Call) Return(_a0 *state.Block, _a1 error) *StorageMock_GetLastBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastBlock_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*state.Block, error)) *StorageMock_GetLastBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastClosedBatch provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastClosedBatch(ctx context.Context, dbTx pgx.Tx) (*state.Batch, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastClosedBatch")
	}

	var r0 *state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*state.Batch, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *state.Batch); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastClosedBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastClosedBatch'
type StorageMock_GetLastClosedBatch_Call struct {
	*mock.Call
}

// GetLastClosedBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastClosedBatch(ctx interface{}, dbTx interface{}) *StorageMock_GetLastClosedBatch_Call {
	return &StorageMock_GetLastClosedBatch_Call{Call: _e.mock.On("GetLastClosedBatch", ctx, dbTx)}
}

func (_c *StorageMock_GetLastClosedBatch_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastClosedBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastClosedBatch_Call) Return(_a0 *state.Batch, _a1 error) *StorageMock_GetLastClosedBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastClosedBatch_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*state.Batch, error)) *StorageMock_GetLastClosedBatch_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastClosedBatchNumber provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastClosedBatchNumber(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastClosedBatchNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastClosedBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastClosedBatchNumber'
type StorageMock_GetLastClosedBatchNumber_Call struct {
	*mock.Call
}

// GetLastClosedBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastClosedBatchNumber(ctx interface{}, dbTx interface{}) *StorageMock_GetLastClosedBatchNumber_Call {
	return &StorageMock_GetLastClosedBatchNumber_Call{Call: _e.mock.On("GetLastClosedBatchNumber", ctx, dbTx)}
}

func (_c *StorageMock_GetLastClosedBatchNumber_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastClosedBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastClosedBatchNumber_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastClosedBatchNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastClosedBatchNumber_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_GetLastClosedBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastConsolidatedL2BlockNumber provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastConsolidatedL2BlockNumber(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastConsolidatedL2BlockNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastConsolidatedL2BlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastConsolidatedL2BlockNumber'
type StorageMock_GetLastConsolidatedL2BlockNumber_Call struct {
	*mock.Call
}

// GetLastConsolidatedL2BlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastConsolidatedL2BlockNumber(ctx interface{}, dbTx interface{}) *StorageMock_GetLastConsolidatedL2BlockNumber_Call {
	return &StorageMock_GetLastConsolidatedL2BlockNumber_Call{Call: _e.mock.On("GetLastConsolidatedL2BlockNumber", ctx, dbTx)}
}

func (_c *StorageMock_GetLastConsolidatedL2BlockNumber_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastConsolidatedL2BlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastConsolidatedL2BlockNumber_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastConsolidatedL2BlockNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastConsolidatedL2BlockNumber_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_GetLastConsolidatedL2BlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastL2Block provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastL2Block(ctx context.Context, dbTx pgx.Tx) (*state.L2Block, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastL2Block")
	}

	var r0 *state.L2Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*state.L2Block, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *state.L2Block); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.L2Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastL2Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastL2Block'
type StorageMock_GetLastL2Block_Call struct {
	*mock.Call
}

// GetLastL2Block is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastL2Block(ctx interface{}, dbTx interface{}) *StorageMock_GetLastL2Block_Call {
	return &StorageMock_GetLastL2Block_Call{Call: _e.mock.On("GetLastL2Block", ctx, dbTx)}
}

func (_c *StorageMock_GetLastL2Block_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastL2Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastL2Block_Call) Return(_a0 *state.L2Block, _a1 error) *StorageMock_GetLastL2Block_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastL2Block_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*state.L2Block, error)) *StorageMock_GetLastL2Block_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastL2BlockCreatedAt provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastL2BlockCreatedAt(ctx context.Context, dbTx pgx.Tx) (*time.Time, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastL2BlockCreatedAt")
	}

	var r0 *time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*time.Time, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *time.Time); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*time.Time)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastL2BlockCreatedAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastL2BlockCreatedAt'
type StorageMock_GetLastL2BlockCreatedAt_Call struct {
	*mock.Call
}

// GetLastL2BlockCreatedAt is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastL2BlockCreatedAt(ctx interface{}, dbTx interface{}) *StorageMock_GetLastL2BlockCreatedAt_Call {
	return &StorageMock_GetLastL2BlockCreatedAt_Call{Call: _e.mock.On("GetLastL2BlockCreatedAt", ctx, dbTx)}
}

func (_c *StorageMock_GetLastL2BlockCreatedAt_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastL2BlockCreatedAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastL2BlockCreatedAt_Call) Return(_a0 *time.Time, _a1 error) *StorageMock_GetLastL2BlockCreatedAt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastL2BlockCreatedAt_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*time.Time, error)) *StorageMock_GetLastL2BlockCreatedAt_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastL2BlockHeader provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastL2BlockHeader(ctx context.Context, dbTx pgx.Tx) (*state.L2Header, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastL2BlockHeader")
	}

	var r0 *state.L2Header
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*state.L2Header, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *state.L2Header); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.L2Header)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastL2BlockHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastL2BlockHeader'
type StorageMock_GetLastL2BlockHeader_Call struct {
	*mock.Call
}

// GetLastL2BlockHeader is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastL2BlockHeader(ctx interface{}, dbTx interface{}) *StorageMock_GetLastL2BlockHeader_Call {
	return &StorageMock_GetLastL2BlockHeader_Call{Call: _e.mock.On("GetLastL2BlockHeader", ctx, dbTx)}
}

func (_c *StorageMock_GetLastL2BlockHeader_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastL2BlockHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastL2BlockHeader_Call) Return(_a0 *state.L2Header, _a1 error) *StorageMock_GetLastL2BlockHeader_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastL2BlockHeader_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*state.L2Header, error)) *StorageMock_GetLastL2BlockHeader_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastL2BlockNumber provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastL2BlockNumber(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastL2BlockNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastL2BlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastL2BlockNumber'
type StorageMock_GetLastL2BlockNumber_Call struct {
	*mock.Call
}

// GetLastL2BlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastL2BlockNumber(ctx interface{}, dbTx interface{}) *StorageMock_GetLastL2BlockNumber_Call {
	return &StorageMock_GetLastL2BlockNumber_Call{Call: _e.mock.On("GetLastL2BlockNumber", ctx, dbTx)}
}

func (_c *StorageMock_GetLastL2BlockNumber_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastL2BlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastL2BlockNumber_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastL2BlockNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastL2BlockNumber_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_GetLastL2BlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastNBatches provides a mock function with given fields: ctx, numBatches, dbTx
func (_m *StorageMock) GetLastNBatches(ctx context.Context, numBatches uint, dbTx pgx.Tx) ([]*state.Batch, error) {
	ret := _m.Called(ctx, numBatches, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastNBatches")
	}

	var r0 []*state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, pgx.Tx) ([]*state.Batch, error)); ok {
		return rf(ctx, numBatches, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, pgx.Tx) []*state.Batch); ok {
		r0 = rf(ctx, numBatches, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, pgx.Tx) error); ok {
		r1 = rf(ctx, numBatches, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastNBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastNBatches'
type StorageMock_GetLastNBatches_Call struct {
	*mock.Call
}

// GetLastNBatches is a helper method to define mock.On call
//   - ctx context.Context
//   - numBatches uint
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastNBatches(ctx interface{}, numBatches interface{}, dbTx interface{}) *StorageMock_GetLastNBatches_Call {
	return &StorageMock_GetLastNBatches_Call{Call: _e.mock.On("GetLastNBatches", ctx, numBatches, dbTx)}
}

func (_c *StorageMock_GetLastNBatches_Call) Run(run func(ctx context.Context, numBatches uint, dbTx pgx.Tx)) *StorageMock_GetLastNBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastNBatches_Call) Return(_a0 []*state.Batch, _a1 error) *StorageMock_GetLastNBatches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastNBatches_Call) RunAndReturn(run func(context.Context, uint, pgx.Tx) ([]*state.Batch, error)) *StorageMock_GetLastNBatches_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastNBatchesByL2BlockNumber provides a mock function with given fields: ctx, l2BlockNumber, numBatches, dbTx
func (_m *StorageMock) GetLastNBatchesByL2BlockNumber(ctx context.Context, l2BlockNumber *uint64, numBatches uint, dbTx pgx.Tx) ([]*state.Batch, common.Hash, error) {
	ret := _m.Called(ctx, l2BlockNumber, numBatches, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastNBatchesByL2BlockNumber")
	}

	var r0 []*state.Batch
	var r1 common.Hash
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *uint64, uint, pgx.Tx) ([]*state.Batch, common.Hash, error)); ok {
		return rf(ctx, l2BlockNumber, numBatches, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *uint64, uint, pgx.Tx) []*state.Batch); ok {
		r0 = rf(ctx, l2BlockNumber, numBatches, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *uint64, uint, pgx.Tx) common.Hash); ok {
		r1 = rf(ctx, l2BlockNumber, numBatches, dbTx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(common.Hash)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *uint64, uint, pgx.Tx) error); ok {
		r2 = rf(ctx, l2BlockNumber, numBatches, dbTx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageMock_GetLastNBatchesByL2BlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastNBatchesByL2BlockNumber'
type StorageMock_GetLastNBatchesByL2BlockNumber_Call struct {
	*mock.Call
}

// GetLastNBatchesByL2BlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - l2BlockNumber *uint64
//   - numBatches uint
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastNBatchesByL2BlockNumber(ctx interface{}, l2BlockNumber interface{}, numBatches interface{}, dbTx interface{}) *StorageMock_GetLastNBatchesByL2BlockNumber_Call {
	return &StorageMock_GetLastNBatchesByL2BlockNumber_Call{Call: _e.mock.On("GetLastNBatchesByL2BlockNumber", ctx, l2BlockNumber, numBatches, dbTx)}
}

func (_c *StorageMock_GetLastNBatchesByL2BlockNumber_Call) Run(run func(ctx context.Context, l2BlockNumber *uint64, numBatches uint, dbTx pgx.Tx)) *StorageMock_GetLastNBatchesByL2BlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*uint64), args[2].(uint), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastNBatchesByL2BlockNumber_Call) Return(_a0 []*state.Batch, _a1 common.Hash, _a2 error) *StorageMock_GetLastNBatchesByL2BlockNumber_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *StorageMock_GetLastNBatchesByL2BlockNumber_Call) RunAndReturn(run func(context.Context, *uint64, uint, pgx.Tx) ([]*state.Batch, common.Hash, error)) *StorageMock_GetLastNBatchesByL2BlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastTrustedForcedBatchNumber provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastTrustedForcedBatchNumber(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastTrustedForcedBatchNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastTrustedForcedBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastTrustedForcedBatchNumber'
type StorageMock_GetLastTrustedForcedBatchNumber_Call struct {
	*mock.Call
}

// GetLastTrustedForcedBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastTrustedForcedBatchNumber(ctx interface{}, dbTx interface{}) *StorageMock_GetLastTrustedForcedBatchNumber_Call {
	return &StorageMock_GetLastTrustedForcedBatchNumber_Call{Call: _e.mock.On("GetLastTrustedForcedBatchNumber", ctx, dbTx)}
}

func (_c *StorageMock_GetLastTrustedForcedBatchNumber_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastTrustedForcedBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastTrustedForcedBatchNumber_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastTrustedForcedBatchNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastTrustedForcedBatchNumber_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_GetLastTrustedForcedBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastVerifiedBatch provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastVerifiedBatch(ctx context.Context, dbTx pgx.Tx) (*state.VerifiedBatch, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastVerifiedBatch")
	}

	var r0 *state.VerifiedBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*state.VerifiedBatch, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *state.VerifiedBatch); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.VerifiedBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastVerifiedBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastVerifiedBatch'
type StorageMock_GetLastVerifiedBatch_Call struct {
	*mock.Call
}

// GetLastVerifiedBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastVerifiedBatch(ctx interface{}, dbTx interface{}) *StorageMock_GetLastVerifiedBatch_Call {
	return &StorageMock_GetLastVerifiedBatch_Call{Call: _e.mock.On("GetLastVerifiedBatch", ctx, dbTx)}
}

func (_c *StorageMock_GetLastVerifiedBatch_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastVerifiedBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastVerifiedBatch_Call) Return(_a0 *state.VerifiedBatch, _a1 error) *StorageMock_GetLastVerifiedBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastVerifiedBatch_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*state.VerifiedBatch, error)) *StorageMock_GetLastVerifiedBatch_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastVerifiedBatchNumberUntilL1Block provides a mock function with given fields: ctx, l1BlockNumber, dbTx
func (_m *StorageMock) GetLastVerifiedBatchNumberUntilL1Block(ctx context.Context, l1BlockNumber uint64, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, l1BlockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastVerifiedBatchNumberUntilL1Block")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, l1BlockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) uint64); ok {
		r0 = rf(ctx, l1BlockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, l1BlockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastVerifiedBatchNumberUntilL1Block'
type StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call struct {
	*mock.Call
}

// GetLastVerifiedBatchNumberUntilL1Block is a helper method to define mock.On call
//   - ctx context.Context
//   - l1BlockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastVerifiedBatchNumberUntilL1Block(ctx interface{}, l1BlockNumber interface{}, dbTx interface{}) *StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call {
	return &StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call{Call: _e.mock.On("GetLastVerifiedBatchNumberUntilL1Block", ctx, l1BlockNumber, dbTx)}
}

func (_c *StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call) Run(run func(ctx context.Context, l1BlockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (uint64, error)) *StorageMock_GetLastVerifiedBatchNumberUntilL1Block_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastVerifiedL2BlockNumberUntilL1Block provides a mock function with given fields: ctx, l1FinalizedBlockNumber, dbTx
func (_m *StorageMock) GetLastVerifiedL2BlockNumberUntilL1Block(ctx context.Context, l1FinalizedBlockNumber uint64, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, l1FinalizedBlockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastVerifiedL2BlockNumberUntilL1Block")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, l1FinalizedBlockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) uint64); ok {
		r0 = rf(ctx, l1FinalizedBlockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, l1FinalizedBlockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastVerifiedL2BlockNumberUntilL1Block'
type StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call struct {
	*mock.Call
}

// GetLastVerifiedL2BlockNumberUntilL1Block is a helper method to define mock.On call
//   - ctx context.Context
//   - l1FinalizedBlockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastVerifiedL2BlockNumberUntilL1Block(ctx interface{}, l1FinalizedBlockNumber interface{}, dbTx interface{}) *StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call {
	return &StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call{Call: _e.mock.On("GetLastVerifiedL2BlockNumberUntilL1Block", ctx, l1FinalizedBlockNumber, dbTx)}
}

func (_c *StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call) Run(run func(ctx context.Context, l1FinalizedBlockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (uint64, error)) *StorageMock_GetLastVerifiedL2BlockNumberUntilL1Block_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastVirtualBatchNum provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastVirtualBatchNum(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastVirtualBatchNum")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastVirtualBatchNum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastVirtualBatchNum'
type StorageMock_GetLastVirtualBatchNum_Call struct {
	*mock.Call
}

// GetLastVirtualBatchNum is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastVirtualBatchNum(ctx interface{}, dbTx interface{}) *StorageMock_GetLastVirtualBatchNum_Call {
	return &StorageMock_GetLastVirtualBatchNum_Call{Call: _e.mock.On("GetLastVirtualBatchNum", ctx, dbTx)}
}

func (_c *StorageMock_GetLastVirtualBatchNum_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastVirtualBatchNum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastVirtualBatchNum_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastVirtualBatchNum_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastVirtualBatchNum_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_GetLastVirtualBatchNum_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastVirtualizedL2BlockNumber provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLastVirtualizedL2BlockNumber(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastVirtualizedL2BlockNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLastVirtualizedL2BlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastVirtualizedL2BlockNumber'
type StorageMock_GetLastVirtualizedL2BlockNumber_Call struct {
	*mock.Call
}

// GetLastVirtualizedL2BlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLastVirtualizedL2BlockNumber(ctx interface{}, dbTx interface{}) *StorageMock_GetLastVirtualizedL2BlockNumber_Call {
	return &StorageMock_GetLastVirtualizedL2BlockNumber_Call{Call: _e.mock.On("GetLastVirtualizedL2BlockNumber", ctx, dbTx)}
}

func (_c *StorageMock_GetLastVirtualizedL2BlockNumber_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLastVirtualizedL2BlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLastVirtualizedL2BlockNumber_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetLastVirtualizedL2BlockNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLastVirtualizedL2BlockNumber_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_GetLastVirtualizedL2BlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestBatchGlobalExitRoot provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLatestBatchGlobalExitRoot(ctx context.Context, dbTx pgx.Tx) (common.Hash, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestBatchGlobalExitRoot")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (common.Hash, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) common.Hash); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLatestBatchGlobalExitRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestBatchGlobalExitRoot'
type StorageMock_GetLatestBatchGlobalExitRoot_Call struct {
	*mock.Call
}

// GetLatestBatchGlobalExitRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLatestBatchGlobalExitRoot(ctx interface{}, dbTx interface{}) *StorageMock_GetLatestBatchGlobalExitRoot_Call {
	return &StorageMock_GetLatestBatchGlobalExitRoot_Call{Call: _e.mock.On("GetLatestBatchGlobalExitRoot", ctx, dbTx)}
}

func (_c *StorageMock_GetLatestBatchGlobalExitRoot_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLatestBatchGlobalExitRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLatestBatchGlobalExitRoot_Call) Return(_a0 common.Hash, _a1 error) *StorageMock_GetLatestBatchGlobalExitRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLatestBatchGlobalExitRoot_Call) RunAndReturn(run func(context.Context, pgx.Tx) (common.Hash, error)) *StorageMock_GetLatestBatchGlobalExitRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestGer provides a mock function with given fields: ctx, maxBlockNumber
func (_m *StorageMock) GetLatestGer(ctx context.Context, maxBlockNumber uint64) (state.GlobalExitRoot, time.Time, error) {
	ret := _m.Called(ctx, maxBlockNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestGer")
	}

	var r0 state.GlobalExitRoot
	var r1 time.Time
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) (state.GlobalExitRoot, time.Time, error)); ok {
		return rf(ctx, maxBlockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64) state.GlobalExitRoot); ok {
		r0 = rf(ctx, maxBlockNumber)
	} else {
		r0 = ret.Get(0).(state.GlobalExitRoot)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64) time.Time); ok {
		r1 = rf(ctx, maxBlockNumber)
	} else {
		r1 = ret.Get(1).(time.Time)
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64) error); ok {
		r2 = rf(ctx, maxBlockNumber)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageMock_GetLatestGer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestGer'
type StorageMock_GetLatestGer_Call struct {
	*mock.Call
}

// GetLatestGer is a helper method to define mock.On call
//   - ctx context.Context
//   - maxBlockNumber uint64
func (_e *StorageMock_Expecter) GetLatestGer(ctx interface{}, maxBlockNumber interface{}) *StorageMock_GetLatestGer_Call {
	return &StorageMock_GetLatestGer_Call{Call: _e.mock.On("GetLatestGer", ctx, maxBlockNumber)}
}

func (_c *StorageMock_GetLatestGer_Call) Run(run func(ctx context.Context, maxBlockNumber uint64)) *StorageMock_GetLatestGer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64))
	})
	return _c
}

func (_c *StorageMock_GetLatestGer_Call) Return(_a0 state.GlobalExitRoot, _a1 time.Time, _a2 error) *StorageMock_GetLatestGer_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *StorageMock_GetLatestGer_Call) RunAndReturn(run func(context.Context, uint64) (state.GlobalExitRoot, time.Time, error)) *StorageMock_GetLatestGer_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestGlobalExitRoot provides a mock function with given fields: ctx, maxBlockNumber, dbTx
func (_m *StorageMock) GetLatestGlobalExitRoot(ctx context.Context, maxBlockNumber uint64, dbTx pgx.Tx) (state.GlobalExitRoot, time.Time, error) {
	ret := _m.Called(ctx, maxBlockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestGlobalExitRoot")
	}

	var r0 state.GlobalExitRoot
	var r1 time.Time
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (state.GlobalExitRoot, time.Time, error)); ok {
		return rf(ctx, maxBlockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) state.GlobalExitRoot); ok {
		r0 = rf(ctx, maxBlockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(state.GlobalExitRoot)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) time.Time); ok {
		r1 = rf(ctx, maxBlockNumber, dbTx)
	} else {
		r1 = ret.Get(1).(time.Time)
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64, pgx.Tx) error); ok {
		r2 = rf(ctx, maxBlockNumber, dbTx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageMock_GetLatestGlobalExitRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestGlobalExitRoot'
type StorageMock_GetLatestGlobalExitRoot_Call struct {
	*mock.Call
}

// GetLatestGlobalExitRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - maxBlockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLatestGlobalExitRoot(ctx interface{}, maxBlockNumber interface{}, dbTx interface{}) *StorageMock_GetLatestGlobalExitRoot_Call {
	return &StorageMock_GetLatestGlobalExitRoot_Call{Call: _e.mock.On("GetLatestGlobalExitRoot", ctx, maxBlockNumber, dbTx)}
}

func (_c *StorageMock_GetLatestGlobalExitRoot_Call) Run(run func(ctx context.Context, maxBlockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetLatestGlobalExitRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLatestGlobalExitRoot_Call) Return(_a0 state.GlobalExitRoot, _a1 time.Time, _a2 error) *StorageMock_GetLatestGlobalExitRoot_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *StorageMock_GetLatestGlobalExitRoot_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (state.GlobalExitRoot, time.Time, error)) *StorageMock_GetLatestGlobalExitRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestIndex provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLatestIndex(ctx context.Context, dbTx pgx.Tx) (uint32, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestIndex")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint32, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint32); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLatestIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestIndex'
type StorageMock_GetLatestIndex_Call struct {
	*mock.Call
}

// GetLatestIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLatestIndex(ctx interface{}, dbTx interface{}) *StorageMock_GetLatestIndex_Call {
	return &StorageMock_GetLatestIndex_Call{Call: _e.mock.On("GetLatestIndex", ctx, dbTx)}
}

func (_c *StorageMock_GetLatestIndex_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLatestIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLatestIndex_Call) Return(_a0 uint32, _a1 error) *StorageMock_GetLatestIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLatestIndex_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint32, error)) *StorageMock_GetLatestIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestL1InfoRoot provides a mock function with given fields: ctx, maxBlockNumber
func (_m *StorageMock) GetLatestL1InfoRoot(ctx context.Context, maxBlockNumber uint64) (state.L1InfoTreeExitRootStorageEntry, error) {
	ret := _m.Called(ctx, maxBlockNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestL1InfoRoot")
	}

	var r0 state.L1InfoTreeExitRootStorageEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) (state.L1InfoTreeExitRootStorageEntry, error)); ok {
		return rf(ctx, maxBlockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64) state.L1InfoTreeExitRootStorageEntry); ok {
		r0 = rf(ctx, maxBlockNumber)
	} else {
		r0 = ret.Get(0).(state.L1InfoTreeExitRootStorageEntry)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, maxBlockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLatestL1InfoRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestL1InfoRoot'
type StorageMock_GetLatestL1InfoRoot_Call struct {
	*mock.Call
}

// GetLatestL1InfoRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - maxBlockNumber uint64
func (_e *StorageMock_Expecter) GetLatestL1InfoRoot(ctx interface{}, maxBlockNumber interface{}) *StorageMock_GetLatestL1InfoRoot_Call {
	return &StorageMock_GetLatestL1InfoRoot_Call{Call: _e.mock.On("GetLatestL1InfoRoot", ctx, maxBlockNumber)}
}

func (_c *StorageMock_GetLatestL1InfoRoot_Call) Run(run func(ctx context.Context, maxBlockNumber uint64)) *StorageMock_GetLatestL1InfoRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64))
	})
	return _c
}

func (_c *StorageMock_GetLatestL1InfoRoot_Call) Return(_a0 state.L1InfoTreeExitRootStorageEntry, _a1 error) *StorageMock_GetLatestL1InfoRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLatestL1InfoRoot_Call) RunAndReturn(run func(context.Context, uint64) (state.L1InfoTreeExitRootStorageEntry, error)) *StorageMock_GetLatestL1InfoRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestVirtualBatchTimestamp provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetLatestVirtualBatchTimestamp(ctx context.Context, dbTx pgx.Tx) (time.Time, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestVirtualBatchTimestamp")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (time.Time, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) time.Time); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLatestVirtualBatchTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestVirtualBatchTimestamp'
type StorageMock_GetLatestVirtualBatchTimestamp_Call struct {
	*mock.Call
}

// GetLatestVirtualBatchTimestamp is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLatestVirtualBatchTimestamp(ctx interface{}, dbTx interface{}) *StorageMock_GetLatestVirtualBatchTimestamp_Call {
	return &StorageMock_GetLatestVirtualBatchTimestamp_Call{Call: _e.mock.On("GetLatestVirtualBatchTimestamp", ctx, dbTx)}
}

func (_c *StorageMock_GetLatestVirtualBatchTimestamp_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetLatestVirtualBatchTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLatestVirtualBatchTimestamp_Call) Return(_a0 time.Time, _a1 error) *StorageMock_GetLatestVirtualBatchTimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLatestVirtualBatchTimestamp_Call) RunAndReturn(run func(context.Context, pgx.Tx) (time.Time, error)) *StorageMock_GetLatestVirtualBatchTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// GetLeafsByL1InfoRoot provides a mock function with given fields: ctx, l1InfoRoot, dbTx
func (_m *StorageMock) GetLeafsByL1InfoRoot(ctx context.Context, l1InfoRoot common.Hash, dbTx pgx.Tx) ([]state.L1InfoTreeExitRootStorageEntry, error) {
	ret := _m.Called(ctx, l1InfoRoot, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLeafsByL1InfoRoot")
	}

	var r0 []state.L1InfoTreeExitRootStorageEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) ([]state.L1InfoTreeExitRootStorageEntry, error)); ok {
		return rf(ctx, l1InfoRoot, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) []state.L1InfoTreeExitRootStorageEntry); ok {
		r0 = rf(ctx, l1InfoRoot, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]state.L1InfoTreeExitRootStorageEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, l1InfoRoot, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLeafsByL1InfoRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLeafsByL1InfoRoot'
type StorageMock_GetLeafsByL1InfoRoot_Call struct {
	*mock.Call
}

// GetLeafsByL1InfoRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - l1InfoRoot common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLeafsByL1InfoRoot(ctx interface{}, l1InfoRoot interface{}, dbTx interface{}) *StorageMock_GetLeafsByL1InfoRoot_Call {
	return &StorageMock_GetLeafsByL1InfoRoot_Call{Call: _e.mock.On("GetLeafsByL1InfoRoot", ctx, l1InfoRoot, dbTx)}
}

func (_c *StorageMock_GetLeafsByL1InfoRoot_Call) Run(run func(ctx context.Context, l1InfoRoot common.Hash, dbTx pgx.Tx)) *StorageMock_GetLeafsByL1InfoRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLeafsByL1InfoRoot_Call) Return(_a0 []state.L1InfoTreeExitRootStorageEntry, _a1 error) *StorageMock_GetLeafsByL1InfoRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLeafsByL1InfoRoot_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) ([]state.L1InfoTreeExitRootStorageEntry, error)) *StorageMock_GetLeafsByL1InfoRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetLocalExitRootByBatchNumber provides a mock function with given fields: ctx, batchNum, dbTx
func (_m *StorageMock) GetLocalExitRootByBatchNumber(ctx context.Context, batchNum uint64, dbTx pgx.Tx) (common.Hash, error) {
	ret := _m.Called(ctx, batchNum, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLocalExitRootByBatchNumber")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (common.Hash, error)); ok {
		return rf(ctx, batchNum, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) common.Hash); ok {
		r0 = rf(ctx, batchNum, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNum, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLocalExitRootByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLocalExitRootByBatchNumber'
type StorageMock_GetLocalExitRootByBatchNumber_Call struct {
	*mock.Call
}

// GetLocalExitRootByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNum uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLocalExitRootByBatchNumber(ctx interface{}, batchNum interface{}, dbTx interface{}) *StorageMock_GetLocalExitRootByBatchNumber_Call {
	return &StorageMock_GetLocalExitRootByBatchNumber_Call{Call: _e.mock.On("GetLocalExitRootByBatchNumber", ctx, batchNum, dbTx)}
}

func (_c *StorageMock_GetLocalExitRootByBatchNumber_Call) Run(run func(ctx context.Context, batchNum uint64, dbTx pgx.Tx)) *StorageMock_GetLocalExitRootByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLocalExitRootByBatchNumber_Call) Return(_a0 common.Hash, _a1 error) *StorageMock_GetLocalExitRootByBatchNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLocalExitRootByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (common.Hash, error)) *StorageMock_GetLocalExitRootByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogs provides a mock function with given fields: ctx, fromBlock, toBlock, addresses, topics, blockHash, since, dbTx
func (_m *StorageMock) GetLogs(ctx context.Context, fromBlock uint64, toBlock uint64, addresses []common.Address, topics [][]common.Hash, blockHash *common.Hash, since *time.Time, dbTx pgx.Tx) ([]*types.Log, error) {
	ret := _m.Called(ctx, fromBlock, toBlock, addresses, topics, blockHash, since, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLogs")
	}

	var r0 []*types.Log
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, []common.Address, [][]common.Hash, *common.Hash, *time.Time, pgx.Tx) ([]*types.Log, error)); ok {
		return rf(ctx, fromBlock, toBlock, addresses, topics, blockHash, since, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, []common.Address, [][]common.Hash, *common.Hash, *time.Time, pgx.Tx) []*types.Log); ok {
		r0 = rf(ctx, fromBlock, toBlock, addresses, topics, blockHash, since, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Log)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, []common.Address, [][]common.Hash, *common.Hash, *time.Time, pgx.Tx) error); ok {
		r1 = rf(ctx, fromBlock, toBlock, addresses, topics, blockHash, since, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogs'
type StorageMock_GetLogs_Call struct {
	*mock.Call
}

// GetLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - fromBlock uint64
//   - toBlock uint64
//   - addresses []common.Address
//   - topics [][]common.Hash
//   - blockHash *common.Hash
//   - since *time.Time
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLogs(ctx interface{}, fromBlock interface{}, toBlock interface{}, addresses interface{}, topics interface{}, blockHash interface{}, since interface{}, dbTx interface{}) *StorageMock_GetLogs_Call {
	return &StorageMock_GetLogs_Call{Call: _e.mock.On("GetLogs", ctx, fromBlock, toBlock, addresses, topics, blockHash, since, dbTx)}
}

func (_c *StorageMock_GetLogs_Call) Run(run func(ctx context.Context, fromBlock uint64, toBlock uint64, addresses []common.Address, topics [][]common.Hash, blockHash *common.Hash, since *time.Time, dbTx pgx.Tx)) *StorageMock_GetLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].([]common.Address), args[4].([][]common.Hash), args[5].(*common.Hash), args[6].(*time.Time), args[7].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLogs_Call) Return(_a0 []*types.Log, _a1 error) *StorageMock_GetLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLogs_Call) RunAndReturn(run func(context.Context, uint64, uint64, []common.Address, [][]common.Hash, *common.Hash, *time.Time, pgx.Tx) ([]*types.Log, error)) *StorageMock_GetLogs_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogsByBlockNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) GetLogsByBlockNumber(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) ([]*types.Log, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLogsByBlockNumber")
	}

	var r0 []*types.Log
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]*types.Log, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []*types.Log); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Log)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetLogsByBlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsByBlockNumber'
type StorageMock_GetLogsByBlockNumber_Call struct {
	*mock.Call
}

// GetLogsByBlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetLogsByBlockNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_GetLogsByBlockNumber_Call {
	return &StorageMock_GetLogsByBlockNumber_Call{Call: _e.mock.On("GetLogsByBlockNumber", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_GetLogsByBlockNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetLogsByBlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetLogsByBlockNumber_Call) Return(_a0 []*types.Log, _a1 error) *StorageMock_GetLogsByBlockNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetLogsByBlockNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]*types.Log, error)) *StorageMock_GetLogsByBlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetNativeBlockHashesInRange provides a mock function with given fields: ctx, fromBlock, toBlock, dbTx
func (_m *StorageMock) GetNativeBlockHashesInRange(ctx context.Context, fromBlock uint64, toBlock uint64, dbTx pgx.Tx) ([]common.Hash, error) {
	ret := _m.Called(ctx, fromBlock, toBlock, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetNativeBlockHashesInRange")
	}

	var r0 []common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) ([]common.Hash, error)); ok {
		return rf(ctx, fromBlock, toBlock, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) []common.Hash); ok {
		r0 = rf(ctx, fromBlock, toBlock, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, fromBlock, toBlock, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetNativeBlockHashesInRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNativeBlockHashesInRange'
type StorageMock_GetNativeBlockHashesInRange_Call struct {
	*mock.Call
}

// GetNativeBlockHashesInRange is a helper method to define mock.On call
//   - ctx context.Context
//   - fromBlock uint64
//   - toBlock uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetNativeBlockHashesInRange(ctx interface{}, fromBlock interface{}, toBlock interface{}, dbTx interface{}) *StorageMock_GetNativeBlockHashesInRange_Call {
	return &StorageMock_GetNativeBlockHashesInRange_Call{Call: _e.mock.On("GetNativeBlockHashesInRange", ctx, fromBlock, toBlock, dbTx)}
}

func (_c *StorageMock_GetNativeBlockHashesInRange_Call) Run(run func(ctx context.Context, fromBlock uint64, toBlock uint64, dbTx pgx.Tx)) *StorageMock_GetNativeBlockHashesInRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetNativeBlockHashesInRange_Call) Return(_a0 []common.Hash, _a1 error) *StorageMock_GetNativeBlockHashesInRange_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetNativeBlockHashesInRange_Call) RunAndReturn(run func(context.Context, uint64, uint64, pgx.Tx) ([]common.Hash, error)) *StorageMock_GetNativeBlockHashesInRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetNextForcedBatches provides a mock function with given fields: ctx, nextForcedBatches, dbTx
func (_m *StorageMock) GetNextForcedBatches(ctx context.Context, nextForcedBatches int, dbTx pgx.Tx) ([]state.ForcedBatch, error) {
	ret := _m.Called(ctx, nextForcedBatches, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetNextForcedBatches")
	}

	var r0 []state.ForcedBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, pgx.Tx) ([]state.ForcedBatch, error)); ok {
		return rf(ctx, nextForcedBatches, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, pgx.Tx) []state.ForcedBatch); ok {
		r0 = rf(ctx, nextForcedBatches, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]state.ForcedBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, pgx.Tx) error); ok {
		r1 = rf(ctx, nextForcedBatches, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetNextForcedBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextForcedBatches'
type StorageMock_GetNextForcedBatches_Call struct {
	*mock.Call
}

// GetNextForcedBatches is a helper method to define mock.On call
//   - ctx context.Context
//   - nextForcedBatches int
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetNextForcedBatches(ctx interface{}, nextForcedBatches interface{}, dbTx interface{}) *StorageMock_GetNextForcedBatches_Call {
	return &StorageMock_GetNextForcedBatches_Call{Call: _e.mock.On("GetNextForcedBatches", ctx, nextForcedBatches, dbTx)}
}

func (_c *StorageMock_GetNextForcedBatches_Call) Run(run func(ctx context.Context, nextForcedBatches int, dbTx pgx.Tx)) *StorageMock_GetNextForcedBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetNextForcedBatches_Call) Return(_a0 []state.ForcedBatch, _a1 error) *StorageMock_GetNextForcedBatches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetNextForcedBatches_Call) RunAndReturn(run func(context.Context, int, pgx.Tx) ([]state.ForcedBatch, error)) *StorageMock_GetNextForcedBatches_Call {
	_c.Call.Return(run)
	return _c
}

// GetNumberOfBlocksSinceLastGERUpdate provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetNumberOfBlocksSinceLastGERUpdate(ctx context.Context, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetNumberOfBlocksSinceLastGERUpdate")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) uint64); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNumberOfBlocksSinceLastGERUpdate'
type StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call struct {
	*mock.Call
}

// GetNumberOfBlocksSinceLastGERUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetNumberOfBlocksSinceLastGERUpdate(ctx interface{}, dbTx interface{}) *StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call {
	return &StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call{Call: _e.mock.On("GetNumberOfBlocksSinceLastGERUpdate", ctx, dbTx)}
}

func (_c *StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call) Return(_a0 uint64, _a1 error) *StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call) RunAndReturn(run func(context.Context, pgx.Tx) (uint64, error)) *StorageMock_GetNumberOfBlocksSinceLastGERUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// GetPreviousBlock provides a mock function with given fields: ctx, offset, dbTx
func (_m *StorageMock) GetPreviousBlock(ctx context.Context, offset uint64, dbTx pgx.Tx) (*state.Block, error) {
	ret := _m.Called(ctx, offset, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetPreviousBlock")
	}

	var r0 *state.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Block, error)); ok {
		return rf(ctx, offset, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Block); ok {
		r0 = rf(ctx, offset, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, offset, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetPreviousBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPreviousBlock'
type StorageMock_GetPreviousBlock_Call struct {
	*mock.Call
}

// GetPreviousBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - offset uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetPreviousBlock(ctx interface{}, offset interface{}, dbTx interface{}) *StorageMock_GetPreviousBlock_Call {
	return &StorageMock_GetPreviousBlock_Call{Call: _e.mock.On("GetPreviousBlock", ctx, offset, dbTx)}
}

func (_c *StorageMock_GetPreviousBlock_Call) Run(run func(ctx context.Context, offset uint64, dbTx pgx.Tx)) *StorageMock_GetPreviousBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetPreviousBlock_Call) Return(_a0 *state.Block, _a1 error) *StorageMock_GetPreviousBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetPreviousBlock_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Block, error)) *StorageMock_GetPreviousBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetProcessingContext provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetProcessingContext(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (*state.ProcessingContext, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetProcessingContext")
	}

	var r0 *state.ProcessingContext
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.ProcessingContext, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.ProcessingContext); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.ProcessingContext)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetProcessingContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProcessingContext'
type StorageMock_GetProcessingContext_Call struct {
	*mock.Call
}

// GetProcessingContext is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetProcessingContext(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetProcessingContext_Call {
	return &StorageMock_GetProcessingContext_Call{Call: _e.mock.On("GetProcessingContext", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetProcessingContext_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetProcessingContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetProcessingContext_Call) Return(_a0 *state.ProcessingContext, _a1 error) *StorageMock_GetProcessingContext_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetProcessingContext_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.ProcessingContext, error)) *StorageMock_GetProcessingContext_Call {
	_c.Call.Return(run)
	return _c
}

// GetProofReadyToVerify provides a mock function with given fields: ctx, lastVerfiedBatchNumber, dbTx
func (_m *StorageMock) GetProofReadyToVerify(ctx context.Context, lastVerfiedBatchNumber uint64, dbTx pgx.Tx) (*state.Proof, error) {
	ret := _m.Called(ctx, lastVerfiedBatchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetProofReadyToVerify")
	}

	var r0 *state.Proof
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Proof, error)); ok {
		return rf(ctx, lastVerfiedBatchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Proof); ok {
		r0 = rf(ctx, lastVerfiedBatchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Proof)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, lastVerfiedBatchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetProofReadyToVerify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProofReadyToVerify'
type StorageMock_GetProofReadyToVerify_Call struct {
	*mock.Call
}

// GetProofReadyToVerify is a helper method to define mock.On call
//   - ctx context.Context
//   - lastVerfiedBatchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetProofReadyToVerify(ctx interface{}, lastVerfiedBatchNumber interface{}, dbTx interface{}) *StorageMock_GetProofReadyToVerify_Call {
	return &StorageMock_GetProofReadyToVerify_Call{Call: _e.mock.On("GetProofReadyToVerify", ctx, lastVerfiedBatchNumber, dbTx)}
}

func (_c *StorageMock_GetProofReadyToVerify_Call) Run(run func(ctx context.Context, lastVerfiedBatchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetProofReadyToVerify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetProofReadyToVerify_Call) Return(_a0 *state.Proof, _a1 error) *StorageMock_GetProofReadyToVerify_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetProofReadyToVerify_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Proof, error)) *StorageMock_GetProofReadyToVerify_Call {
	_c.Call.Return(run)
	return _c
}

// GetProofsToAggregate provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetProofsToAggregate(ctx context.Context, dbTx pgx.Tx) (*state.Proof, *state.Proof, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetProofsToAggregate")
	}

	var r0 *state.Proof
	var r1 *state.Proof
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (*state.Proof, *state.Proof, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) *state.Proof); ok {
		r0 = rf(ctx, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Proof)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) *state.Proof); ok {
		r1 = rf(ctx, dbTx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*state.Proof)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, pgx.Tx) error); ok {
		r2 = rf(ctx, dbTx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageMock_GetProofsToAggregate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProofsToAggregate'
type StorageMock_GetProofsToAggregate_Call struct {
	*mock.Call
}

// GetProofsToAggregate is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetProofsToAggregate(ctx interface{}, dbTx interface{}) *StorageMock_GetProofsToAggregate_Call {
	return &StorageMock_GetProofsToAggregate_Call{Call: _e.mock.On("GetProofsToAggregate", ctx, dbTx)}
}

func (_c *StorageMock_GetProofsToAggregate_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetProofsToAggregate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetProofsToAggregate_Call) Return(_a0 *state.Proof, _a1 *state.Proof, _a2 error) *StorageMock_GetProofsToAggregate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *StorageMock_GetProofsToAggregate_Call) RunAndReturn(run func(context.Context, pgx.Tx) (*state.Proof, *state.Proof, error)) *StorageMock_GetProofsToAggregate_Call {
	_c.Call.Return(run)
	return _c
}

// GetRawBatchTimestamps provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetRawBatchTimestamps(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (*time.Time, *time.Time, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetRawBatchTimestamps")
	}

	var r0 *time.Time
	var r1 *time.Time
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*time.Time, *time.Time, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *time.Time); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*time.Time)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) *time.Time); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*time.Time)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64, pgx.Tx) error); ok {
		r2 = rf(ctx, batchNumber, dbTx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageMock_GetRawBatchTimestamps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRawBatchTimestamps'
type StorageMock_GetRawBatchTimestamps_Call struct {
	*mock.Call
}

// GetRawBatchTimestamps is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetRawBatchTimestamps(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetRawBatchTimestamps_Call {
	return &StorageMock_GetRawBatchTimestamps_Call{Call: _e.mock.On("GetRawBatchTimestamps", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetRawBatchTimestamps_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetRawBatchTimestamps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetRawBatchTimestamps_Call) Return(_a0 *time.Time, _a1 *time.Time, _a2 error) *StorageMock_GetRawBatchTimestamps_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *StorageMock_GetRawBatchTimestamps_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*time.Time, *time.Time, error)) *StorageMock_GetRawBatchTimestamps_Call {
	_c.Call.Return(run)
	return _c
}

// GetReorgedTransactions provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetReorgedTransactions(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) ([]*types.Transaction, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetReorgedTransactions")
	}

	var r0 []*types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]*types.Transaction, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []*types.Transaction); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetReorgedTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReorgedTransactions'
type StorageMock_GetReorgedTransactions_Call struct {
	*mock.Call
}

// GetReorgedTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetReorgedTransactions(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetReorgedTransactions_Call {
	return &StorageMock_GetReorgedTransactions_Call{Call: _e.mock.On("GetReorgedTransactions", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetReorgedTransactions_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetReorgedTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetReorgedTransactions_Call) Return(_a0 []*types.Transaction, _a1 error) *StorageMock_GetReorgedTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetReorgedTransactions_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]*types.Transaction, error)) *StorageMock_GetReorgedTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// GetSequences provides a mock function with given fields: ctx, lastVerifiedBatchNumber, dbTx
func (_m *StorageMock) GetSequences(ctx context.Context, lastVerifiedBatchNumber uint64, dbTx pgx.Tx) ([]state.Sequence, error) {
	ret := _m.Called(ctx, lastVerifiedBatchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetSequences")
	}

	var r0 []state.Sequence
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]state.Sequence, error)); ok {
		return rf(ctx, lastVerifiedBatchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []state.Sequence); ok {
		r0 = rf(ctx, lastVerifiedBatchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]state.Sequence)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, lastVerifiedBatchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetSequences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSequences'
type StorageMock_GetSequences_Call struct {
	*mock.Call
}

// GetSequences is a helper method to define mock.On call
//   - ctx context.Context
//   - lastVerifiedBatchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetSequences(ctx interface{}, lastVerifiedBatchNumber interface{}, dbTx interface{}) *StorageMock_GetSequences_Call {
	return &StorageMock_GetSequences_Call{Call: _e.mock.On("GetSequences", ctx, lastVerifiedBatchNumber, dbTx)}
}

func (_c *StorageMock_GetSequences_Call) Run(run func(ctx context.Context, lastVerifiedBatchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetSequences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetSequences_Call) Return(_a0 []state.Sequence, _a1 error) *StorageMock_GetSequences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetSequences_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]state.Sequence, error)) *StorageMock_GetSequences_Call {
	_c.Call.Return(run)
	return _c
}

// GetStateRootByBatchNumber provides a mock function with given fields: ctx, batchNum, dbTx
func (_m *StorageMock) GetStateRootByBatchNumber(ctx context.Context, batchNum uint64, dbTx pgx.Tx) (common.Hash, error) {
	ret := _m.Called(ctx, batchNum, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetStateRootByBatchNumber")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (common.Hash, error)); ok {
		return rf(ctx, batchNum, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) common.Hash); ok {
		r0 = rf(ctx, batchNum, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNum, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetStateRootByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStateRootByBatchNumber'
type StorageMock_GetStateRootByBatchNumber_Call struct {
	*mock.Call
}

// GetStateRootByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNum uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetStateRootByBatchNumber(ctx interface{}, batchNum interface{}, dbTx interface{}) *StorageMock_GetStateRootByBatchNumber_Call {
	return &StorageMock_GetStateRootByBatchNumber_Call{Call: _e.mock.On("GetStateRootByBatchNumber", ctx, batchNum, dbTx)}
}

func (_c *StorageMock_GetStateRootByBatchNumber_Call) Run(run func(ctx context.Context, batchNum uint64, dbTx pgx.Tx)) *StorageMock_GetStateRootByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetStateRootByBatchNumber_Call) Return(_a0 common.Hash, _a1 error) *StorageMock_GetStateRootByBatchNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetStateRootByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (common.Hash, error)) *StorageMock_GetStateRootByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetSyncingInfo provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetSyncingInfo(ctx context.Context, dbTx pgx.Tx) (state.SyncingInfo, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetSyncingInfo")
	}

	var r0 state.SyncingInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (state.SyncingInfo, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) state.SyncingInfo); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(state.SyncingInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetSyncingInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSyncingInfo'
type StorageMock_GetSyncingInfo_Call struct {
	*mock.Call
}

// GetSyncingInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetSyncingInfo(ctx interface{}, dbTx interface{}) *StorageMock_GetSyncingInfo_Call {
	return &StorageMock_GetSyncingInfo_Call{Call: _e.mock.On("GetSyncingInfo", ctx, dbTx)}
}

func (_c *StorageMock_GetSyncingInfo_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetSyncingInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetSyncingInfo_Call) Return(_a0 state.SyncingInfo, _a1 error) *StorageMock_GetSyncingInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetSyncingInfo_Call) RunAndReturn(run func(context.Context, pgx.Tx) (state.SyncingInfo, error)) *StorageMock_GetSyncingInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetTimeForLatestBatchVirtualization provides a mock function with given fields: ctx, dbTx
func (_m *StorageMock) GetTimeForLatestBatchVirtualization(ctx context.Context, dbTx pgx.Tx) (time.Time, error) {
	ret := _m.Called(ctx, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTimeForLatestBatchVirtualization")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) (time.Time, error)); ok {
		return rf(ctx, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx) time.Time); ok {
		r0 = rf(ctx, dbTx)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx) error); ok {
		r1 = rf(ctx, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTimeForLatestBatchVirtualization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTimeForLatestBatchVirtualization'
type StorageMock_GetTimeForLatestBatchVirtualization_Call struct {
	*mock.Call
}

// GetTimeForLatestBatchVirtualization is a helper method to define mock.On call
//   - ctx context.Context
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTimeForLatestBatchVirtualization(ctx interface{}, dbTx interface{}) *StorageMock_GetTimeForLatestBatchVirtualization_Call {
	return &StorageMock_GetTimeForLatestBatchVirtualization_Call{Call: _e.mock.On("GetTimeForLatestBatchVirtualization", ctx, dbTx)}
}

func (_c *StorageMock_GetTimeForLatestBatchVirtualization_Call) Run(run func(ctx context.Context, dbTx pgx.Tx)) *StorageMock_GetTimeForLatestBatchVirtualization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTimeForLatestBatchVirtualization_Call) Return(_a0 time.Time, _a1 error) *StorageMock_GetTimeForLatestBatchVirtualization_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTimeForLatestBatchVirtualization_Call) RunAndReturn(run func(context.Context, pgx.Tx) (time.Time, error)) *StorageMock_GetTimeForLatestBatchVirtualization_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByHash provides a mock function with given fields: ctx, transactionHash, dbTx
func (_m *StorageMock) GetTransactionByHash(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx) (*types.Transaction, error) {
	ret := _m.Called(ctx, transactionHash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByHash")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*types.Transaction, error)); ok {
		return rf(ctx, transactionHash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *types.Transaction); ok {
		r0 = rf(ctx, transactionHash, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, transactionHash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTransactionByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByHash'
type StorageMock_GetTransactionByHash_Call struct {
	*mock.Call
}

// GetTransactionByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionHash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTransactionByHash(ctx interface{}, transactionHash interface{}, dbTx interface{}) *StorageMock_GetTransactionByHash_Call {
	return &StorageMock_GetTransactionByHash_Call{Call: _e.mock.On("GetTransactionByHash", ctx, transactionHash, dbTx)}
}

func (_c *StorageMock_GetTransactionByHash_Call) Run(run func(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx)) *StorageMock_GetTransactionByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTransactionByHash_Call) Return(_a0 *types.Transaction, _a1 error) *StorageMock_GetTransactionByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTransactionByHash_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*types.Transaction, error)) *StorageMock_GetTransactionByHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByL2BlockHashAndIndex provides a mock function with given fields: ctx, blockHash, index, dbTx
func (_m *StorageMock) GetTransactionByL2BlockHashAndIndex(ctx context.Context, blockHash common.Hash, index uint64, dbTx pgx.Tx) (*types.Transaction, error) {
	ret := _m.Called(ctx, blockHash, index, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByL2BlockHashAndIndex")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, uint64, pgx.Tx) (*types.Transaction, error)); ok {
		return rf(ctx, blockHash, index, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, uint64, pgx.Tx) *types.Transaction); ok {
		r0 = rf(ctx, blockHash, index, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockHash, index, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTransactionByL2BlockHashAndIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByL2BlockHashAndIndex'
type StorageMock_GetTransactionByL2BlockHashAndIndex_Call struct {
	*mock.Call
}

// GetTransactionByL2BlockHashAndIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - blockHash common.Hash
//   - index uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTransactionByL2BlockHashAndIndex(ctx interface{}, blockHash interface{}, index interface{}, dbTx interface{}) *StorageMock_GetTransactionByL2BlockHashAndIndex_Call {
	return &StorageMock_GetTransactionByL2BlockHashAndIndex_Call{Call: _e.mock.On("GetTransactionByL2BlockHashAndIndex", ctx, blockHash, index, dbTx)}
}

func (_c *StorageMock_GetTransactionByL2BlockHashAndIndex_Call) Run(run func(ctx context.Context, blockHash common.Hash, index uint64, dbTx pgx.Tx)) *StorageMock_GetTransactionByL2BlockHashAndIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(uint64), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTransactionByL2BlockHashAndIndex_Call) Return(_a0 *types.Transaction, _a1 error) *StorageMock_GetTransactionByL2BlockHashAndIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTransactionByL2BlockHashAndIndex_Call) RunAndReturn(run func(context.Context, common.Hash, uint64, pgx.Tx) (*types.Transaction, error)) *StorageMock_GetTransactionByL2BlockHashAndIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByL2BlockNumberAndIndex provides a mock function with given fields: ctx, blockNumber, index, dbTx
func (_m *StorageMock) GetTransactionByL2BlockNumberAndIndex(ctx context.Context, blockNumber uint64, index uint64, dbTx pgx.Tx) (*types.Transaction, error) {
	ret := _m.Called(ctx, blockNumber, index, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByL2BlockNumberAndIndex")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) (*types.Transaction, error)); ok {
		return rf(ctx, blockNumber, index, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) *types.Transaction); ok {
		r0 = rf(ctx, blockNumber, index, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, index, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTransactionByL2BlockNumberAndIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByL2BlockNumberAndIndex'
type StorageMock_GetTransactionByL2BlockNumberAndIndex_Call struct {
	*mock.Call
}

// GetTransactionByL2BlockNumberAndIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - index uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTransactionByL2BlockNumberAndIndex(ctx interface{}, blockNumber interface{}, index interface{}, dbTx interface{}) *StorageMock_GetTransactionByL2BlockNumberAndIndex_Call {
	return &StorageMock_GetTransactionByL2BlockNumberAndIndex_Call{Call: _e.mock.On("GetTransactionByL2BlockNumberAndIndex", ctx, blockNumber, index, dbTx)}
}

func (_c *StorageMock_GetTransactionByL2BlockNumberAndIndex_Call) Run(run func(ctx context.Context, blockNumber uint64, index uint64, dbTx pgx.Tx)) *StorageMock_GetTransactionByL2BlockNumberAndIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTransactionByL2BlockNumberAndIndex_Call) Return(_a0 *types.Transaction, _a1 error) *StorageMock_GetTransactionByL2BlockNumberAndIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTransactionByL2BlockNumberAndIndex_Call) RunAndReturn(run func(context.Context, uint64, uint64, pgx.Tx) (*types.Transaction, error)) *StorageMock_GetTransactionByL2BlockNumberAndIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByL2Hash provides a mock function with given fields: ctx, transactionHash, dbTx
func (_m *StorageMock) GetTransactionByL2Hash(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx) (*types.Transaction, error) {
	ret := _m.Called(ctx, transactionHash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByL2Hash")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*types.Transaction, error)); ok {
		return rf(ctx, transactionHash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *types.Transaction); ok {
		r0 = rf(ctx, transactionHash, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, transactionHash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTransactionByL2Hash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByL2Hash'
type StorageMock_GetTransactionByL2Hash_Call struct {
	*mock.Call
}

// GetTransactionByL2Hash is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionHash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTransactionByL2Hash(ctx interface{}, transactionHash interface{}, dbTx interface{}) *StorageMock_GetTransactionByL2Hash_Call {
	return &StorageMock_GetTransactionByL2Hash_Call{Call: _e.mock.On("GetTransactionByL2Hash", ctx, transactionHash, dbTx)}
}

func (_c *StorageMock_GetTransactionByL2Hash_Call) Run(run func(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx)) *StorageMock_GetTransactionByL2Hash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTransactionByL2Hash_Call) Return(_a0 *types.Transaction, _a1 error) *StorageMock_GetTransactionByL2Hash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTransactionByL2Hash_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*types.Transaction, error)) *StorageMock_GetTransactionByL2Hash_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionEGPLogByHash provides a mock function with given fields: ctx, transactionHash, dbTx
func (_m *StorageMock) GetTransactionEGPLogByHash(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx) (*state.EffectiveGasPriceLog, error) {
	ret := _m.Called(ctx, transactionHash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionEGPLogByHash")
	}

	var r0 *state.EffectiveGasPriceLog
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*state.EffectiveGasPriceLog, error)); ok {
		return rf(ctx, transactionHash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *state.EffectiveGasPriceLog); ok {
		r0 = rf(ctx, transactionHash, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.EffectiveGasPriceLog)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, transactionHash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTransactionEGPLogByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionEGPLogByHash'
type StorageMock_GetTransactionEGPLogByHash_Call struct {
	*mock.Call
}

// GetTransactionEGPLogByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionHash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTransactionEGPLogByHash(ctx interface{}, transactionHash interface{}, dbTx interface{}) *StorageMock_GetTransactionEGPLogByHash_Call {
	return &StorageMock_GetTransactionEGPLogByHash_Call{Call: _e.mock.On("GetTransactionEGPLogByHash", ctx, transactionHash, dbTx)}
}

func (_c *StorageMock_GetTransactionEGPLogByHash_Call) Run(run func(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx)) *StorageMock_GetTransactionEGPLogByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTransactionEGPLogByHash_Call) Return(_a0 *state.EffectiveGasPriceLog, _a1 error) *StorageMock_GetTransactionEGPLogByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTransactionEGPLogByHash_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*state.EffectiveGasPriceLog, error)) *StorageMock_GetTransactionEGPLogByHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionReceipt provides a mock function with given fields: ctx, transactionHash, dbTx
func (_m *StorageMock) GetTransactionReceipt(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx) (*types.Receipt, error) {
	ret := _m.Called(ctx, transactionHash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionReceipt")
	}

	var r0 *types.Receipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*types.Receipt, error)); ok {
		return rf(ctx, transactionHash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *types.Receipt); ok {
		r0 = rf(ctx, transactionHash, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Receipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, transactionHash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTransactionReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionReceipt'
type StorageMock_GetTransactionReceipt_Call struct {
	*mock.Call
}

// GetTransactionReceipt is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionHash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTransactionReceipt(ctx interface{}, transactionHash interface{}, dbTx interface{}) *StorageMock_GetTransactionReceipt_Call {
	return &StorageMock_GetTransactionReceipt_Call{Call: _e.mock.On("GetTransactionReceipt", ctx, transactionHash, dbTx)}
}

func (_c *StorageMock_GetTransactionReceipt_Call) Run(run func(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx)) *StorageMock_GetTransactionReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTransactionReceipt_Call) Return(_a0 *types.Receipt, _a1 error) *StorageMock_GetTransactionReceipt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTransactionReceipt_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*types.Receipt, error)) *StorageMock_GetTransactionReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionsByBatchNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetTransactionsByBatchNumber(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) ([]types.Transaction, []uint8, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionsByBatchNumber")
	}

	var r0 []types.Transaction
	var r1 []uint8
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]types.Transaction, []uint8, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []types.Transaction); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) []uint8); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]uint8)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64, pgx.Tx) error); ok {
		r2 = rf(ctx, batchNumber, dbTx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageMock_GetTransactionsByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionsByBatchNumber'
type StorageMock_GetTransactionsByBatchNumber_Call struct {
	*mock.Call
}

// GetTransactionsByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTransactionsByBatchNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetTransactionsByBatchNumber_Call {
	return &StorageMock_GetTransactionsByBatchNumber_Call{Call: _e.mock.On("GetTransactionsByBatchNumber", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetTransactionsByBatchNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetTransactionsByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTransactionsByBatchNumber_Call) Return(txs []types.Transaction, effectivePercentages []uint8, err error) *StorageMock_GetTransactionsByBatchNumber_Call {
	_c.Call.Return(txs, effectivePercentages, err)
	return _c
}

func (_c *StorageMock_GetTransactionsByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]types.Transaction, []uint8, error)) *StorageMock_GetTransactionsByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetTxsByBatchNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetTxsByBatchNumber(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) ([]*types.Transaction, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTxsByBatchNumber")
	}

	var r0 []*types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]*types.Transaction, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []*types.Transaction); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTxsByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTxsByBatchNumber'
type StorageMock_GetTxsByBatchNumber_Call struct {
	*mock.Call
}

// GetTxsByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTxsByBatchNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetTxsByBatchNumber_Call {
	return &StorageMock_GetTxsByBatchNumber_Call{Call: _e.mock.On("GetTxsByBatchNumber", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetTxsByBatchNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetTxsByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTxsByBatchNumber_Call) Return(_a0 []*types.Transaction, _a1 error) *StorageMock_GetTxsByBatchNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTxsByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]*types.Transaction, error)) *StorageMock_GetTxsByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetTxsByBlockNumber provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) GetTxsByBlockNumber(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) ([]*types.Transaction, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTxsByBlockNumber")
	}

	var r0 []*types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]*types.Transaction, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []*types.Transaction); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTxsByBlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTxsByBlockNumber'
type StorageMock_GetTxsByBlockNumber_Call struct {
	*mock.Call
}

// GetTxsByBlockNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTxsByBlockNumber(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_GetTxsByBlockNumber_Call {
	return &StorageMock_GetTxsByBlockNumber_Call{Call: _e.mock.On("GetTxsByBlockNumber", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_GetTxsByBlockNumber_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_GetTxsByBlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTxsByBlockNumber_Call) Return(_a0 []*types.Transaction, _a1 error) *StorageMock_GetTxsByBlockNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTxsByBlockNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]*types.Transaction, error)) *StorageMock_GetTxsByBlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetTxsHashesByBatchNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetTxsHashesByBatchNumber(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) ([]common.Hash, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTxsHashesByBatchNumber")
	}

	var r0 []common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]common.Hash, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []common.Hash); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTxsHashesByBatchNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTxsHashesByBatchNumber'
type StorageMock_GetTxsHashesByBatchNumber_Call struct {
	*mock.Call
}

// GetTxsHashesByBatchNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTxsHashesByBatchNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetTxsHashesByBatchNumber_Call {
	return &StorageMock_GetTxsHashesByBatchNumber_Call{Call: _e.mock.On("GetTxsHashesByBatchNumber", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetTxsHashesByBatchNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetTxsHashesByBatchNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTxsHashesByBatchNumber_Call) Return(encoded []common.Hash, err error) *StorageMock_GetTxsHashesByBatchNumber_Call {
	_c.Call.Return(encoded, err)
	return _c
}

func (_c *StorageMock_GetTxsHashesByBatchNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]common.Hash, error)) *StorageMock_GetTxsHashesByBatchNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetTxsOlderThanNL1Blocks provides a mock function with given fields: ctx, nL1Blocks, dbTx
func (_m *StorageMock) GetTxsOlderThanNL1Blocks(ctx context.Context, nL1Blocks uint64, dbTx pgx.Tx) ([]common.Hash, error) {
	ret := _m.Called(ctx, nL1Blocks, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTxsOlderThanNL1Blocks")
	}

	var r0 []common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) ([]common.Hash, error)); ok {
		return rf(ctx, nL1Blocks, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) []common.Hash); ok {
		r0 = rf(ctx, nL1Blocks, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, nL1Blocks, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetTxsOlderThanNL1Blocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTxsOlderThanNL1Blocks'
type StorageMock_GetTxsOlderThanNL1Blocks_Call struct {
	*mock.Call
}

// GetTxsOlderThanNL1Blocks is a helper method to define mock.On call
//   - ctx context.Context
//   - nL1Blocks uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetTxsOlderThanNL1Blocks(ctx interface{}, nL1Blocks interface{}, dbTx interface{}) *StorageMock_GetTxsOlderThanNL1Blocks_Call {
	return &StorageMock_GetTxsOlderThanNL1Blocks_Call{Call: _e.mock.On("GetTxsOlderThanNL1Blocks", ctx, nL1Blocks, dbTx)}
}

func (_c *StorageMock_GetTxsOlderThanNL1Blocks_Call) Run(run func(ctx context.Context, nL1Blocks uint64, dbTx pgx.Tx)) *StorageMock_GetTxsOlderThanNL1Blocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetTxsOlderThanNL1Blocks_Call) Return(_a0 []common.Hash, _a1 error) *StorageMock_GetTxsOlderThanNL1Blocks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetTxsOlderThanNL1Blocks_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) ([]common.Hash, error)) *StorageMock_GetTxsOlderThanNL1Blocks_Call {
	_c.Call.Return(run)
	return _c
}

// GetVerifiedBatch provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetVerifiedBatch(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (*state.VerifiedBatch, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetVerifiedBatch")
	}

	var r0 *state.VerifiedBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.VerifiedBatch, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.VerifiedBatch); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.VerifiedBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetVerifiedBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVerifiedBatch'
type StorageMock_GetVerifiedBatch_Call struct {
	*mock.Call
}

// GetVerifiedBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetVerifiedBatch(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetVerifiedBatch_Call {
	return &StorageMock_GetVerifiedBatch_Call{Call: _e.mock.On("GetVerifiedBatch", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetVerifiedBatch_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetVerifiedBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetVerifiedBatch_Call) Return(_a0 *state.VerifiedBatch, _a1 error) *StorageMock_GetVerifiedBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetVerifiedBatch_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.VerifiedBatch, error)) *StorageMock_GetVerifiedBatch_Call {
	_c.Call.Return(run)
	return _c
}

// GetVirtualBatch provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetVirtualBatch(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (*state.VirtualBatch, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetVirtualBatch")
	}

	var r0 *state.VirtualBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.VirtualBatch, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.VirtualBatch); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.VirtualBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetVirtualBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVirtualBatch'
type StorageMock_GetVirtualBatch_Call struct {
	*mock.Call
}

// GetVirtualBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetVirtualBatch(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetVirtualBatch_Call {
	return &StorageMock_GetVirtualBatch_Call{Call: _e.mock.On("GetVirtualBatch", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetVirtualBatch_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetVirtualBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetVirtualBatch_Call) Return(_a0 *state.VirtualBatch, _a1 error) *StorageMock_GetVirtualBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetVirtualBatch_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.VirtualBatch, error)) *StorageMock_GetVirtualBatch_Call {
	_c.Call.Return(run)
	return _c
}

// GetVirtualBatchByNumber provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetVirtualBatchByNumber(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (*state.Batch, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetVirtualBatchByNumber")
	}

	var r0 *state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Batch, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Batch); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetVirtualBatchByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVirtualBatchByNumber'
type StorageMock_GetVirtualBatchByNumber_Call struct {
	*mock.Call
}

// GetVirtualBatchByNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetVirtualBatchByNumber(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetVirtualBatchByNumber_Call {
	return &StorageMock_GetVirtualBatchByNumber_Call{Call: _e.mock.On("GetVirtualBatchByNumber", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetVirtualBatchByNumber_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetVirtualBatchByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetVirtualBatchByNumber_Call) Return(_a0 *state.Batch, _a1 error) *StorageMock_GetVirtualBatchByNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetVirtualBatchByNumber_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Batch, error)) *StorageMock_GetVirtualBatchByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetVirtualBatchParentHash provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetVirtualBatchParentHash(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (common.Hash, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetVirtualBatchParentHash")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (common.Hash, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) common.Hash); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetVirtualBatchParentHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVirtualBatchParentHash'
type StorageMock_GetVirtualBatchParentHash_Call struct {
	*mock.Call
}

// GetVirtualBatchParentHash is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetVirtualBatchParentHash(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetVirtualBatchParentHash_Call {
	return &StorageMock_GetVirtualBatchParentHash_Call{Call: _e.mock.On("GetVirtualBatchParentHash", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetVirtualBatchParentHash_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetVirtualBatchParentHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetVirtualBatchParentHash_Call) Return(_a0 common.Hash, _a1 error) *StorageMock_GetVirtualBatchParentHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetVirtualBatchParentHash_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (common.Hash, error)) *StorageMock_GetVirtualBatchParentHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetVirtualBatchToProve provides a mock function with given fields: ctx, lastVerfiedBatchNumber, dbTx
func (_m *StorageMock) GetVirtualBatchToProve(ctx context.Context, lastVerfiedBatchNumber uint64, dbTx pgx.Tx) (*state.Batch, error) {
	ret := _m.Called(ctx, lastVerfiedBatchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetVirtualBatchToProve")
	}

	var r0 *state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Batch, error)); ok {
		return rf(ctx, lastVerfiedBatchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Batch); ok {
		r0 = rf(ctx, lastVerfiedBatchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, lastVerfiedBatchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetVirtualBatchToProve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVirtualBatchToProve'
type StorageMock_GetVirtualBatchToProve_Call struct {
	*mock.Call
}

// GetVirtualBatchToProve is a helper method to define mock.On call
//   - ctx context.Context
//   - lastVerfiedBatchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetVirtualBatchToProve(ctx interface{}, lastVerfiedBatchNumber interface{}, dbTx interface{}) *StorageMock_GetVirtualBatchToProve_Call {
	return &StorageMock_GetVirtualBatchToProve_Call{Call: _e.mock.On("GetVirtualBatchToProve", ctx, lastVerfiedBatchNumber, dbTx)}
}

func (_c *StorageMock_GetVirtualBatchToProve_Call) Run(run func(ctx context.Context, lastVerfiedBatchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetVirtualBatchToProve_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetVirtualBatchToProve_Call) Return(_a0 *state.Batch, _a1 error) *StorageMock_GetVirtualBatchToProve_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetVirtualBatchToProve_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Batch, error)) *StorageMock_GetVirtualBatchToProve_Call {
	_c.Call.Return(run)
	return _c
}

// GetWIPBatchInStorage provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) GetWIPBatchInStorage(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (*state.Batch, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetWIPBatchInStorage")
	}

	var r0 *state.Batch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (*state.Batch, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) *state.Batch); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Batch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_GetWIPBatchInStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWIPBatchInStorage'
type StorageMock_GetWIPBatchInStorage_Call struct {
	*mock.Call
}

// GetWIPBatchInStorage is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) GetWIPBatchInStorage(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_GetWIPBatchInStorage_Call {
	return &StorageMock_GetWIPBatchInStorage_Call{Call: _e.mock.On("GetWIPBatchInStorage", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_GetWIPBatchInStorage_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_GetWIPBatchInStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_GetWIPBatchInStorage_Call) Return(_a0 *state.Batch, _a1 error) *StorageMock_GetWIPBatchInStorage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_GetWIPBatchInStorage_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (*state.Batch, error)) *StorageMock_GetWIPBatchInStorage_Call {
	_c.Call.Return(run)
	return _c
}

// IsBatchClosed provides a mock function with given fields: ctx, batchNum, dbTx
func (_m *StorageMock) IsBatchClosed(ctx context.Context, batchNum uint64, dbTx pgx.Tx) (bool, error) {
	ret := _m.Called(ctx, batchNum, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for IsBatchClosed")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (bool, error)); ok {
		return rf(ctx, batchNum, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) bool); ok {
		r0 = rf(ctx, batchNum, dbTx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNum, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_IsBatchClosed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsBatchClosed'
type StorageMock_IsBatchClosed_Call struct {
	*mock.Call
}

// IsBatchClosed is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNum uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) IsBatchClosed(ctx interface{}, batchNum interface{}, dbTx interface{}) *StorageMock_IsBatchClosed_Call {
	return &StorageMock_IsBatchClosed_Call{Call: _e.mock.On("IsBatchClosed", ctx, batchNum, dbTx)}
}

func (_c *StorageMock_IsBatchClosed_Call) Run(run func(ctx context.Context, batchNum uint64, dbTx pgx.Tx)) *StorageMock_IsBatchClosed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_IsBatchClosed_Call) Return(_a0 bool, _a1 error) *StorageMock_IsBatchClosed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_IsBatchClosed_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (bool, error)) *StorageMock_IsBatchClosed_Call {
	_c.Call.Return(run)
	return _c
}

// IsBatchConsolidated provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) IsBatchConsolidated(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (bool, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for IsBatchConsolidated")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (bool, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) bool); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_IsBatchConsolidated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsBatchConsolidated'
type StorageMock_IsBatchConsolidated_Call struct {
	*mock.Call
}

// IsBatchConsolidated is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) IsBatchConsolidated(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_IsBatchConsolidated_Call {
	return &StorageMock_IsBatchConsolidated_Call{Call: _e.mock.On("IsBatchConsolidated", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_IsBatchConsolidated_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_IsBatchConsolidated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_IsBatchConsolidated_Call) Return(_a0 bool, _a1 error) *StorageMock_IsBatchConsolidated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_IsBatchConsolidated_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (bool, error)) *StorageMock_IsBatchConsolidated_Call {
	_c.Call.Return(run)
	return _c
}

// IsBatchVirtualized provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) IsBatchVirtualized(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) (bool, error) {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for IsBatchVirtualized")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (bool, error)); ok {
		return rf(ctx, batchNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) bool); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, batchNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_IsBatchVirtualized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsBatchVirtualized'
type StorageMock_IsBatchVirtualized_Call struct {
	*mock.Call
}

// IsBatchVirtualized is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) IsBatchVirtualized(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_IsBatchVirtualized_Call {
	return &StorageMock_IsBatchVirtualized_Call{Call: _e.mock.On("IsBatchVirtualized", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_IsBatchVirtualized_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_IsBatchVirtualized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_IsBatchVirtualized_Call) Return(_a0 bool, _a1 error) *StorageMock_IsBatchVirtualized_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_IsBatchVirtualized_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (bool, error)) *StorageMock_IsBatchVirtualized_Call {
	_c.Call.Return(run)
	return _c
}

// IsL2BlockConsolidated provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) IsL2BlockConsolidated(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) (bool, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for IsL2BlockConsolidated")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (bool, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) bool); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_IsL2BlockConsolidated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsL2BlockConsolidated'
type StorageMock_IsL2BlockConsolidated_Call struct {
	*mock.Call
}

// IsL2BlockConsolidated is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) IsL2BlockConsolidated(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_IsL2BlockConsolidated_Call {
	return &StorageMock_IsL2BlockConsolidated_Call{Call: _e.mock.On("IsL2BlockConsolidated", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_IsL2BlockConsolidated_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_IsL2BlockConsolidated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_IsL2BlockConsolidated_Call) Return(_a0 bool, _a1 error) *StorageMock_IsL2BlockConsolidated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_IsL2BlockConsolidated_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (bool, error)) *StorageMock_IsL2BlockConsolidated_Call {
	_c.Call.Return(run)
	return _c
}

// IsL2BlockVirtualized provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) IsL2BlockVirtualized(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) (bool, error) {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for IsL2BlockVirtualized")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) (bool, error)); ok {
		return rf(ctx, blockNumber, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) bool); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, pgx.Tx) error); ok {
		r1 = rf(ctx, blockNumber, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_IsL2BlockVirtualized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsL2BlockVirtualized'
type StorageMock_IsL2BlockVirtualized_Call struct {
	*mock.Call
}

// IsL2BlockVirtualized is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) IsL2BlockVirtualized(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_IsL2BlockVirtualized_Call {
	return &StorageMock_IsL2BlockVirtualized_Call{Call: _e.mock.On("IsL2BlockVirtualized", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_IsL2BlockVirtualized_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_IsL2BlockVirtualized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_IsL2BlockVirtualized_Call) Return(_a0 bool, _a1 error) *StorageMock_IsL2BlockVirtualized_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_IsL2BlockVirtualized_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) (bool, error)) *StorageMock_IsL2BlockVirtualized_Call {
	_c.Call.Return(run)
	return _c
}

// IsSequencingTXSynced provides a mock function with given fields: ctx, transactionHash, dbTx
func (_m *StorageMock) IsSequencingTXSynced(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx) (bool, error) {
	ret := _m.Called(ctx, transactionHash, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for IsSequencingTXSynced")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (bool, error)); ok {
		return rf(ctx, transactionHash, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) bool); ok {
		r0 = rf(ctx, transactionHash, dbTx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, transactionHash, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_IsSequencingTXSynced_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSequencingTXSynced'
type StorageMock_IsSequencingTXSynced_Call struct {
	*mock.Call
}

// IsSequencingTXSynced is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionHash common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) IsSequencingTXSynced(ctx interface{}, transactionHash interface{}, dbTx interface{}) *StorageMock_IsSequencingTXSynced_Call {
	return &StorageMock_IsSequencingTXSynced_Call{Call: _e.mock.On("IsSequencingTXSynced", ctx, transactionHash, dbTx)}
}

func (_c *StorageMock_IsSequencingTXSynced_Call) Run(run func(ctx context.Context, transactionHash common.Hash, dbTx pgx.Tx)) *StorageMock_IsSequencingTXSynced_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_IsSequencingTXSynced_Call) Return(_a0 bool, _a1 error) *StorageMock_IsSequencingTXSynced_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_IsSequencingTXSynced_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (bool, error)) *StorageMock_IsSequencingTXSynced_Call {
	_c.Call.Return(run)
	return _c
}

// OpenBatchInStorage provides a mock function with given fields: ctx, batchContext, dbTx
func (_m *StorageMock) OpenBatchInStorage(ctx context.Context, batchContext state.ProcessingContext, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchContext, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for OpenBatchInStorage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.ProcessingContext, pgx.Tx) error); ok {
		r0 = rf(ctx, batchContext, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_OpenBatchInStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenBatchInStorage'
type StorageMock_OpenBatchInStorage_Call struct {
	*mock.Call
}

// OpenBatchInStorage is a helper method to define mock.On call
//   - ctx context.Context
//   - batchContext state.ProcessingContext
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) OpenBatchInStorage(ctx interface{}, batchContext interface{}, dbTx interface{}) *StorageMock_OpenBatchInStorage_Call {
	return &StorageMock_OpenBatchInStorage_Call{Call: _e.mock.On("OpenBatchInStorage", ctx, batchContext, dbTx)}
}

func (_c *StorageMock_OpenBatchInStorage_Call) Run(run func(ctx context.Context, batchContext state.ProcessingContext, dbTx pgx.Tx)) *StorageMock_OpenBatchInStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.ProcessingContext), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_OpenBatchInStorage_Call) Return(_a0 error) *StorageMock_OpenBatchInStorage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_OpenBatchInStorage_Call) RunAndReturn(run func(context.Context, state.ProcessingContext, pgx.Tx) error) *StorageMock_OpenBatchInStorage_Call {
	_c.Call.Return(run)
	return _c
}

// OpenWIPBatchInStorage provides a mock function with given fields: ctx, batch, dbTx
func (_m *StorageMock) OpenWIPBatchInStorage(ctx context.Context, batch state.Batch, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batch, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for OpenWIPBatchInStorage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.Batch, pgx.Tx) error); ok {
		r0 = rf(ctx, batch, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_OpenWIPBatchInStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenWIPBatchInStorage'
type StorageMock_OpenWIPBatchInStorage_Call struct {
	*mock.Call
}

// OpenWIPBatchInStorage is a helper method to define mock.On call
//   - ctx context.Context
//   - batch state.Batch
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) OpenWIPBatchInStorage(ctx interface{}, batch interface{}, dbTx interface{}) *StorageMock_OpenWIPBatchInStorage_Call {
	return &StorageMock_OpenWIPBatchInStorage_Call{Call: _e.mock.On("OpenWIPBatchInStorage", ctx, batch, dbTx)}
}

func (_c *StorageMock_OpenWIPBatchInStorage_Call) Run(run func(ctx context.Context, batch state.Batch, dbTx pgx.Tx)) *StorageMock_OpenWIPBatchInStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.Batch), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_OpenWIPBatchInStorage_Call) Return(_a0 error) *StorageMock_OpenWIPBatchInStorage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_OpenWIPBatchInStorage_Call) RunAndReturn(run func(context.Context, state.Batch, pgx.Tx) error) *StorageMock_OpenWIPBatchInStorage_Call {
	_c.Call.Return(run)
	return _c
}

// Query provides a mock function with given fields: ctx, sql, args
func (_m *StorageMock) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) {
	var _ca []interface{}
	_ca = append(_ca, ctx, sql)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 pgx.Rows
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (pgx.Rows, error)); ok {
		return rf(ctx, sql, args...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Rows); ok {
		r0 = rf(ctx, sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Rows)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok {
		r1 = rf(ctx, sql, args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageMock_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type StorageMock_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - args ...interface{}
func (_e *StorageMock_Expecter) Query(ctx interface{}, sql interface{}, args ...interface{}) *StorageMock_Query_Call {
	return &StorageMock_Query_Call{Call: _e.mock.On("Query",
		append([]interface{}{ctx, sql}, args...)...)}
}

func (_c *StorageMock_Query_Call) Run(run func(ctx context.Context, sql string, args ...interface{})) *StorageMock_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *StorageMock_Query_Call) Return(_a0 pgx.Rows, _a1 error) *StorageMock_Query_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StorageMock_Query_Call) RunAndReturn(run func(context.Context, string, ...interface{}) (pgx.Rows, error)) *StorageMock_Query_Call {
	_c.Call.Return(run)
	return _c
}

// QueryRow provides a mock function with given fields: ctx, sql, args
func (_m *StorageMock) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row {
	var _ca []interface{}
	_ca = append(_ca, ctx, sql)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryRow")
	}

	var r0 pgx.Row
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Row); ok {
		r0 = rf(ctx, sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Row)
		}
	}

	return r0
}

// StorageMock_QueryRow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRow'
type StorageMock_QueryRow_Call struct {
	*mock.Call
}

// QueryRow is a helper method to define mock.On call
//   - ctx context.Context
//   - sql string
//   - args ...interface{}
func (_e *StorageMock_Expecter) QueryRow(ctx interface{}, sql interface{}, args ...interface{}) *StorageMock_QueryRow_Call {
	return &StorageMock_QueryRow_Call{Call: _e.mock.On("QueryRow",
		append([]interface{}{ctx, sql}, args...)...)}
}

func (_c *StorageMock_QueryRow_Call) Run(run func(ctx context.Context, sql string, args ...interface{})) *StorageMock_QueryRow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *StorageMock_QueryRow_Call) Return(_a0 pgx.Row) *StorageMock_QueryRow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_QueryRow_Call) RunAndReturn(run func(context.Context, string, ...interface{}) pgx.Row) *StorageMock_QueryRow_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function with given fields: ctx, blockNumber, dbTx
func (_m *StorageMock) Reset(ctx context.Context, blockNumber uint64, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, blockNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for Reset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) error); ok {
		r0 = rf(ctx, blockNumber, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type StorageMock_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) Reset(ctx interface{}, blockNumber interface{}, dbTx interface{}) *StorageMock_Reset_Call {
	return &StorageMock_Reset_Call{Call: _e.mock.On("Reset", ctx, blockNumber, dbTx)}
}

func (_c *StorageMock_Reset_Call) Run(run func(ctx context.Context, blockNumber uint64, dbTx pgx.Tx)) *StorageMock_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_Reset_Call) Return(_a0 error) *StorageMock_Reset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_Reset_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) error) *StorageMock_Reset_Call {
	_c.Call.Return(run)
	return _c
}

// ResetForkID provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) ResetForkID(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for ResetForkID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) error); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_ResetForkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetForkID'
type StorageMock_ResetForkID_Call struct {
	*mock.Call
}

// ResetForkID is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) ResetForkID(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_ResetForkID_Call {
	return &StorageMock_ResetForkID_Call{Call: _e.mock.On("ResetForkID", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_ResetForkID_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_ResetForkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_ResetForkID_Call) Return(_a0 error) *StorageMock_ResetForkID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_ResetForkID_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) error) *StorageMock_ResetForkID_Call {
	_c.Call.Return(run)
	return _c
}

// ResetTrustedState provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) ResetTrustedState(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for ResetTrustedState")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) error); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_ResetTrustedState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetTrustedState'
type StorageMock_ResetTrustedState_Call struct {
	*mock.Call
}

// ResetTrustedState is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) ResetTrustedState(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_ResetTrustedState_Call {
	return &StorageMock_ResetTrustedState_Call{Call: _e.mock.On("ResetTrustedState", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_ResetTrustedState_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_ResetTrustedState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_ResetTrustedState_Call) Return(_a0 error) *StorageMock_ResetTrustedState_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_ResetTrustedState_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) error) *StorageMock_ResetTrustedState_Call {
	_c.Call.Return(run)
	return _c
}

// SetInitSyncBatch provides a mock function with given fields: ctx, batchNumber, dbTx
func (_m *StorageMock) SetInitSyncBatch(ctx context.Context, batchNumber uint64, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchNumber, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for SetInitSyncBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, pgx.Tx) error); ok {
		r0 = rf(ctx, batchNumber, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_SetInitSyncBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetInitSyncBatch'
type StorageMock_SetInitSyncBatch_Call struct {
	*mock.Call
}

// SetInitSyncBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) SetInitSyncBatch(ctx interface{}, batchNumber interface{}, dbTx interface{}) *StorageMock_SetInitSyncBatch_Call {
	return &StorageMock_SetInitSyncBatch_Call{Call: _e.mock.On("SetInitSyncBatch", ctx, batchNumber, dbTx)}
}

func (_c *StorageMock_SetInitSyncBatch_Call) Run(run func(ctx context.Context, batchNumber uint64, dbTx pgx.Tx)) *StorageMock_SetInitSyncBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_SetInitSyncBatch_Call) Return(_a0 error) *StorageMock_SetInitSyncBatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_SetInitSyncBatch_Call) RunAndReturn(run func(context.Context, uint64, pgx.Tx) error) *StorageMock_SetInitSyncBatch_Call {
	_c.Call.Return(run)
	return _c
}

// SetLastBatchInfoSeenOnEthereum provides a mock function with given fields: ctx, lastBatchNumberSeen, lastBatchNumberVerified, dbTx
func (_m *StorageMock) SetLastBatchInfoSeenOnEthereum(ctx context.Context, lastBatchNumberSeen uint64, lastBatchNumberVerified uint64, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, lastBatchNumberSeen, lastBatchNumberVerified, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for SetLastBatchInfoSeenOnEthereum")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, pgx.Tx) error); ok {
		r0 = rf(ctx, lastBatchNumberSeen, lastBatchNumberVerified, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_SetLastBatchInfoSeenOnEthereum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLastBatchInfoSeenOnEthereum'
type StorageMock_SetLastBatchInfoSeenOnEthereum_Call struct {
	*mock.Call
}

// SetLastBatchInfoSeenOnEthereum is a helper method to define mock.On call
//   - ctx context.Context
//   - lastBatchNumberSeen uint64
//   - lastBatchNumberVerified uint64
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) SetLastBatchInfoSeenOnEthereum(ctx interface{}, lastBatchNumberSeen interface{}, lastBatchNumberVerified interface{}, dbTx interface{}) *StorageMock_SetLastBatchInfoSeenOnEthereum_Call {
	return &StorageMock_SetLastBatchInfoSeenOnEthereum_Call{Call: _e.mock.On("SetLastBatchInfoSeenOnEthereum", ctx, lastBatchNumberSeen, lastBatchNumberVerified, dbTx)}
}

func (_c *StorageMock_SetLastBatchInfoSeenOnEthereum_Call) Run(run func(ctx context.Context, lastBatchNumberSeen uint64, lastBatchNumberVerified uint64, dbTx pgx.Tx)) *StorageMock_SetLastBatchInfoSeenOnEthereum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_SetLastBatchInfoSeenOnEthereum_Call) Return(_a0 error) *StorageMock_SetLastBatchInfoSeenOnEthereum_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_SetLastBatchInfoSeenOnEthereum_Call) RunAndReturn(run func(context.Context, uint64, uint64, pgx.Tx) error) *StorageMock_SetLastBatchInfoSeenOnEthereum_Call {
	_c.Call.Return(run)
	return _c
}

// StoreGenesisBatch provides a mock function with given fields: ctx, batch, dbTx
func (_m *StorageMock) StoreGenesisBatch(ctx context.Context, batch state.Batch, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batch, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for StoreGenesisBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.Batch, pgx.Tx) error); ok {
		r0 = rf(ctx, batch, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_StoreGenesisBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreGenesisBatch'
type StorageMock_StoreGenesisBatch_Call struct {
	*mock.Call
}

// StoreGenesisBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - batch state.Batch
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) StoreGenesisBatch(ctx interface{}, batch interface{}, dbTx interface{}) *StorageMock_StoreGenesisBatch_Call {
	return &StorageMock_StoreGenesisBatch_Call{Call: _e.mock.On("StoreGenesisBatch", ctx, batch, dbTx)}
}

func (_c *StorageMock_StoreGenesisBatch_Call) Run(run func(ctx context.Context, batch state.Batch, dbTx pgx.Tx)) *StorageMock_StoreGenesisBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.Batch), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_StoreGenesisBatch_Call) Return(_a0 error) *StorageMock_StoreGenesisBatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_StoreGenesisBatch_Call) RunAndReturn(run func(context.Context, state.Batch, pgx.Tx) error) *StorageMock_StoreGenesisBatch_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBatchL2Data provides a mock function with given fields: ctx, batchNumber, batchL2Data, dbTx
func (_m *StorageMock) UpdateBatchL2Data(ctx context.Context, batchNumber uint64, batchL2Data []byte, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, batchNumber, batchL2Data, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBatchL2Data")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, []byte, pgx.Tx) error); ok {
		r0 = rf(ctx, batchNumber, batchL2Data, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_UpdateBatchL2Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBatchL2Data'
type StorageMock_UpdateBatchL2Data_Call struct {
	*mock.Call
}

// UpdateBatchL2Data is a helper method to define mock.On call
//   - ctx context.Context
//   - batchNumber uint64
//   - batchL2Data []byte
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) UpdateBatchL2Data(ctx interface{}, batchNumber interface{}, batchL2Data interface{}, dbTx interface{}) *StorageMock_UpdateBatchL2Data_Call {
	return &StorageMock_UpdateBatchL2Data_Call{Call: _e.mock.On("UpdateBatchL2Data", ctx, batchNumber, batchL2Data, dbTx)}
}

func (_c *StorageMock_UpdateBatchL2Data_Call) Run(run func(ctx context.Context, batchNumber uint64, batchL2Data []byte, dbTx pgx.Tx)) *StorageMock_UpdateBatchL2Data_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].([]byte), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_UpdateBatchL2Data_Call) Return(_a0 error) *StorageMock_UpdateBatchL2Data_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_UpdateBatchL2Data_Call) RunAndReturn(run func(context.Context, uint64, []byte, pgx.Tx) error) *StorageMock_UpdateBatchL2Data_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateForkID provides a mock function with given fields: ctx, forkID, dbTx
func (_m *StorageMock) UpdateForkID(ctx context.Context, forkID state.ForkIDInterval, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, forkID, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for UpdateForkID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.ForkIDInterval, pgx.Tx) error); ok {
		r0 = rf(ctx, forkID, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_UpdateForkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateForkID'
type StorageMock_UpdateForkID_Call struct {
	*mock.Call
}

// UpdateForkID is a helper method to define mock.On call
//   - ctx context.Context
//   - forkID state.ForkIDInterval
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) UpdateForkID(ctx interface{}, forkID interface{}, dbTx interface{}) *StorageMock_UpdateForkID_Call {
	return &StorageMock_UpdateForkID_Call{Call: _e.mock.On("UpdateForkID", ctx, forkID, dbTx)}
}

func (_c *StorageMock_UpdateForkID_Call) Run(run func(ctx context.Context, forkID state.ForkIDInterval, dbTx pgx.Tx)) *StorageMock_UpdateForkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.ForkIDInterval), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_UpdateForkID_Call) Return(_a0 error) *StorageMock_UpdateForkID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_UpdateForkID_Call) RunAndReturn(run func(context.Context, state.ForkIDInterval, pgx.Tx) error) *StorageMock_UpdateForkID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateForkIDIntervalsInMemory provides a mock function with given fields: intervals
func (_m *StorageMock) UpdateForkIDIntervalsInMemory(intervals []state.ForkIDInterval) {
	_m.Called(intervals)
}

// StorageMock_UpdateForkIDIntervalsInMemory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateForkIDIntervalsInMemory'
type StorageMock_UpdateForkIDIntervalsInMemory_Call struct {
	*mock.Call
}

// UpdateForkIDIntervalsInMemory is a helper method to define mock.On call
//   - intervals []state.ForkIDInterval
func (_e *StorageMock_Expecter) UpdateForkIDIntervalsInMemory(intervals interface{}) *StorageMock_UpdateForkIDIntervalsInMemory_Call {
	return &StorageMock_UpdateForkIDIntervalsInMemory_Call{Call: _e.mock.On("UpdateForkIDIntervalsInMemory", intervals)}
}

func (_c *StorageMock_UpdateForkIDIntervalsInMemory_Call) Run(run func(intervals []state.ForkIDInterval)) *StorageMock_UpdateForkIDIntervalsInMemory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]state.ForkIDInterval))
	})
	return _c
}

func (_c *StorageMock_UpdateForkIDIntervalsInMemory_Call) Return() *StorageMock_UpdateForkIDIntervalsInMemory_Call {
	_c.Call.Return()
	return _c
}

func (_c *StorageMock_UpdateForkIDIntervalsInMemory_Call) RunAndReturn(run func([]state.ForkIDInterval)) *StorageMock_UpdateForkIDIntervalsInMemory_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGERInOpenBatch provides a mock function with given fields: ctx, ger, dbTx
func (_m *StorageMock) UpdateGERInOpenBatch(ctx context.Context, ger common.Hash, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, ger, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGERInOpenBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r0 = rf(ctx, ger, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_UpdateGERInOpenBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGERInOpenBatch'
type StorageMock_UpdateGERInOpenBatch_Call struct {
	*mock.Call
}

// UpdateGERInOpenBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - ger common.Hash
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) UpdateGERInOpenBatch(ctx interface{}, ger interface{}, dbTx interface{}) *StorageMock_UpdateGERInOpenBatch_Call {
	return &StorageMock_UpdateGERInOpenBatch_Call{Call: _e.mock.On("UpdateGERInOpenBatch", ctx, ger, dbTx)}
}

func (_c *StorageMock_UpdateGERInOpenBatch_Call) Run(run func(ctx context.Context, ger common.Hash, dbTx pgx.Tx)) *StorageMock_UpdateGERInOpenBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_UpdateGERInOpenBatch_Call) Return(_a0 error) *StorageMock_UpdateGERInOpenBatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_UpdateGERInOpenBatch_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) error) *StorageMock_UpdateGERInOpenBatch_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGeneratedProof provides a mock function with given fields: ctx, proof, dbTx
func (_m *StorageMock) UpdateGeneratedProof(ctx context.Context, proof *state.Proof, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, proof, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGeneratedProof")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *state.Proof, pgx.Tx) error); ok {
		r0 = rf(ctx, proof, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_UpdateGeneratedProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGeneratedProof'
type StorageMock_UpdateGeneratedProof_Call struct {
	*mock.Call
}

// UpdateGeneratedProof is a helper method to define mock.On call
//   - ctx context.Context
//   - proof *state.Proof
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) UpdateGeneratedProof(ctx interface{}, proof interface{}, dbTx interface{}) *StorageMock_UpdateGeneratedProof_Call {
	return &StorageMock_UpdateGeneratedProof_Call{Call: _e.mock.On("UpdateGeneratedProof", ctx, proof, dbTx)}
}

func (_c *StorageMock_UpdateGeneratedProof_Call) Run(run func(ctx context.Context, proof *state.Proof, dbTx pgx.Tx)) *StorageMock_UpdateGeneratedProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*state.Proof), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_UpdateGeneratedProof_Call) Return(_a0 error) *StorageMock_UpdateGeneratedProof_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_UpdateGeneratedProof_Call) RunAndReturn(run func(context.Context, *state.Proof, pgx.Tx) error) *StorageMock_UpdateGeneratedProof_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWIPBatch provides a mock function with given fields: ctx, receipt, dbTx
func (_m *StorageMock) UpdateWIPBatch(ctx context.Context, receipt state.ProcessingReceipt, dbTx pgx.Tx) error {
	ret := _m.Called(ctx, receipt, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWIPBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, state.ProcessingReceipt, pgx.Tx) error); ok {
		r0 = rf(ctx, receipt, dbTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageMock_UpdateWIPBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWIPBatch'
type StorageMock_UpdateWIPBatch_Call struct {
	*mock.Call
}

// UpdateWIPBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - receipt state.ProcessingReceipt
//   - dbTx pgx.Tx
func (_e *StorageMock_Expecter) UpdateWIPBatch(ctx interface{}, receipt interface{}, dbTx interface{}) *StorageMock_UpdateWIPBatch_Call {
	return &StorageMock_UpdateWIPBatch_Call{Call: _e.mock.On("UpdateWIPBatch", ctx, receipt, dbTx)}
}

func (_c *StorageMock_UpdateWIPBatch_Call) Run(run func(ctx context.Context, receipt state.ProcessingReceipt, dbTx pgx.Tx)) *StorageMock_UpdateWIPBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(state.ProcessingReceipt), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *StorageMock_UpdateWIPBatch_Call) Return(_a0 error) *StorageMock_UpdateWIPBatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StorageMock_UpdateWIPBatch_Call) RunAndReturn(run func(context.Context, state.ProcessingReceipt, pgx.Tx) error) *StorageMock_UpdateWIPBatch_Call {
	_c.Call.Return(run)
	return _c
}

// NewStorageMock creates a new instance of StorageMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStorageMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *StorageMock {
	mock := &StorageMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
