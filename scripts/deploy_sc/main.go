package main

import (
	"context"
	"errors"
	"math/big"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/hermeznetwork/hermez-core/encoding"
	"github.com/hermeznetwork/hermez-core/log"
	"github.com/hermeznetwork/hermez-core/test/contracts/bin/Counter"
	"github.com/hermeznetwork/hermez-core/test/contracts/bin/ERC20"
	"github.com/hermeznetwork/hermez-core/test/contracts/bin/EmitLog"
	"github.com/hermeznetwork/hermez-core/test/contracts/bin/Storage"
)

const (
	networkURL    = "http://localhost:8123"
	accPrivateKey = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"

	txMinedTimeoutLimit = 60 * time.Second
)

// this function sends a transaction to deploy a smartcontract to the local network
func main() {
	ctx := context.Background()

	log.Infof("connecting to %v", networkURL)
	client, err := ethclient.Dial(networkURL)
	chkErr(err)
	log.Infof("connected")

	auth := getAuth(ctx, client)

	const receiverAddr = "0x617b3a3528F9cDd6630fd3301B9c8911F7Bf063D"

	// Valid ETH Transfer
	to := common.HexToAddress(receiverAddr)
	amount, _ := big.NewInt(0).SetString("10000000000000000000", encoding.Base10)
	tx := ethTransfer(ctx, client, auth, to, amount, nil)

	// Invalid ETH Transfer
	amount, _ = big.NewInt(0).SetString("1000000000000000000000", encoding.Base10)
	nonce := tx.Nonce() + 1
	tx2 := ethTransfer(ctx, client, auth, to, amount, &nonce)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)
	_, err = waitTxToBeMined(client, tx2.Hash(), txMinedTimeoutLimit)
	chkErr(err)

	// Counter
	_, tx, counterSC, err := Counter.DeployCounter(auth, client)
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)
	tx, err = counterSC.Increment(auth)
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)

	// EmitLog
	_, tx, emitLogSC, err := EmitLog.DeployEmitLog(auth, client)
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)
	tx, err = emitLogSC.EmitLogs(auth)
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)

	// ERC20
	mintAmount, _ := big.NewInt(0).SetString("1000000000000000000000", encoding.Base10)
	_, tx, erc20SC, err := ERC20.DeployERC20(auth, client, "Test Coin", "TCO")
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)
	tx, err = erc20SC.Mint(auth, mintAmount)
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)
	transferAmount, _ := big.NewInt(0).SetString("900000000000000000000", encoding.Base10)
	tx, err = erc20SC.Transfer(auth, common.HexToAddress(receiverAddr), transferAmount)
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)

	// invalid transfer - no enough balance
	// TODO: Check how to by pass the nonce automatically generated by the code to allow this transaction to be sent
	// together with the previous transfer, so it can be mined as an invalid transaction
	// transferAmount, _ = big.NewInt(0).SetString("2000000000000000000000", encoding.Base10)
	// tx, err = erc20SC.Transfer(auth, common.HexToAddress(receiverAddr), transferAmount)
	// chkErr(err)
	// _, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	// chkErr(err)

	// Storage
	const numberToStore = 22
	_, tx, storageSC, err := Storage.DeployStorage(auth, client)
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)
	tx, err = storageSC.Store(auth, big.NewInt(numberToStore))
	chkErr(err)
	_, err = waitTxToBeMined(client, tx.Hash(), txMinedTimeoutLimit)
	chkErr(err)
}

func ethTransfer(ctx context.Context, client *ethclient.Client, auth *bind.TransactOpts, to common.Address, amount *big.Int, nonce *uint64) *types.Transaction {
	if nonce == nil {
		log.Infof("reading nonce for account: %v", auth.From.Hex())
		var err error
		n, err := client.NonceAt(ctx, auth.From, nil)
		log.Infof("nonce: %v", n)
		chkErr(err)
		nonce = &n
	}

	gasPrice, err := client.SuggestGasPrice(context.Background())
	chkErr(err)

	gasLimit, err := client.EstimateGas(context.Background(), ethereum.CallMsg{To: &to})
	chkErr(err)

	tx := types.NewTransaction(*nonce, to, amount, gasLimit, gasPrice, nil)

	signedTx, err := auth.Signer(auth.From, tx)
	chkErr(err)

	log.Infof("sending transfer tx")
	err = client.SendTransaction(ctx, signedTx)
	chkErr(err)
	log.Infof("tx sent: %v", signedTx.Hash().Hex())

	return signedTx
}

func getAuth(ctx context.Context, client *ethclient.Client) *bind.TransactOpts {
	chainID, err := client.ChainID(ctx)
	chkErr(err)
	log.Infof("chainID: %v", chainID)

	privateKey, err := crypto.HexToECDSA(strings.TrimPrefix(accPrivateKey, "0x"))
	chkErr(err)
	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
	chkErr(err)

	return auth
}

func waitTxToBeMined(client *ethclient.Client, hash common.Hash, timeout time.Duration) (*types.Receipt, error) {
	log.Infof("waiting tx to be mined: %v", hash.Hex())
	start := time.Now()
	for {
		if time.Since(start) > timeout {
			return nil, errors.New("timeout exceed")
		}

		r, err := client.TransactionReceipt(context.Background(), hash)
		if errors.Is(err, ethereum.NotFound) {
			time.Sleep(1 * time.Second)
			continue
		}
		if err != nil {
			log.Errorf("Failed to get tx receipt: %v", err)
			return nil, err
		}

		if r.Status == types.ReceiptStatusFailed {
			log.Errorf("tx mined[FAILED]: %v", hash.Hex())
		} else {
			log.Infof("tx mined[SUCCESS]: %v", hash.Hex())
		}

		return r, nil
	}
}

func chkErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
