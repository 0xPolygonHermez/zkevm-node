// Code generated by mockery v2.22.1. DO NOT EDIT.

package sequencer

import (
	context "context"

	common "github.com/ethereum/go-ethereum/common"

	mock "github.com/stretchr/testify/mock"

	state "github.com/0xPolygonHermez/zkevm-node/state"
)

// FinalizerMock is an autogenerated mock type for the finalizerInterface type
type FinalizerMock struct {
	mock.Mock
}

// Start provides a mock function with given fields: ctx, batch, processingReq
func (_m *FinalizerMock) Start(ctx context.Context, batch *WipBatch, processingReq *state.ProcessRequest) {
	_m.Called(ctx, batch, processingReq)
}

// getBatch provides a mock function with given fields:
func (_m *FinalizerMock) getBatch() *WipBatch {
	ret := _m.Called()

	var r0 *WipBatch
	if rf, ok := ret.Get(0).(func() *WipBatch); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WipBatch)
		}
	}

	return r0
}

// getCurrentBatchNumber provides a mock function with given fields:
func (_m *FinalizerMock) getCurrentBatchNumber() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// getLastBatchNumAndOldStateRoot provides a mock function with given fields: ctx
func (_m *FinalizerMock) getLastBatchNumAndOldStateRoot(ctx context.Context) (uint64, common.Hash, error) {
	ret := _m.Called(ctx)

	var r0 uint64
	var r1 common.Hash
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, common.Hash, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) common.Hash); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(common.Hash)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// getProcessRequest provides a mock function with given fields:
func (_m *FinalizerMock) getProcessRequest() *state.ProcessRequest {
	ret := _m.Called()

	var r0 *state.ProcessRequest
	if rf, ok := ret.Get(0).(func() *state.ProcessRequest); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.ProcessRequest)
		}
	}

	return r0
}

// resumeProcessing provides a mock function with given fields:
func (_m *FinalizerMock) resumeProcessing() {
	_m.Called()
}

// stopAfterCurrentBatch provides a mock function with given fields:
func (_m *FinalizerMock) stopAfterCurrentBatch() {
	_m.Called()
}

// stopAtBatch provides a mock function with given fields: batchNumber
func (_m *FinalizerMock) stopAtBatch(batchNumber uint64) {
	_m.Called(batchNumber)
}

// syncWithState provides a mock function with given fields: ctx, lastBatchNum
func (_m *FinalizerMock) syncWithState(ctx context.Context, lastBatchNum *uint64) error {
	ret := _m.Called(ctx, lastBatchNum)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *uint64) error); ok {
		r0 = rf(ctx, lastBatchNum)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewFinalizerMock interface {
	mock.TestingT
	Cleanup(func())
}

// NewFinalizerMock creates a new instance of FinalizerMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewFinalizerMock(t mockConstructorTestingTNewFinalizerMock) *FinalizerMock {
	mock := &FinalizerMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
